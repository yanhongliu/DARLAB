# Generated by tools/asdl_py.py
from pypy.interpreter.baseobjspace import Wrappable, ObjSpace, W_Root
from pypy.interpreter import typedef
from pypy.interpreter.gateway import interp2app
from pypy.interpreter.argument import Arguments
from pypy.interpreter.error import OperationError
from pypy.rlib.unroll import unrolling_iterable
from pypy.tool.pairtype import extendabletype
from pypy.tool.sourcetools import func_with_new_name


class AST(Wrappable):

    __slots__ = ("initialization_state",)

    __metaclass__ = extendabletype

    def walkabout(self, visitor):
        raise AssertionError("walkabout() implementation not provided")

    def mutate_over(self, visitor):
        raise AssertionError("mutate_over() implementation not provided")

    def sync_app_attrs(self, space):
        raise NotImplementedError


class NodeVisitorNotImplemented(Exception):
    pass


class _FieldsWrapper(Wrappable):
    "Hack around the fact we can't store tuples on a TypeDef."

    def __init__(self, fields):
        self.fields = fields

    def __spacebind__(self, space):
        return space.newtuple([space.wrap(field) for field in self.fields])


def get_AST_new(node_class):
    def generic_AST_new(space, w_type, __args__):
        node = space.allocate_instance(node_class, w_type)
        node.initialization_state = 0
        return space.wrap(node)
    generic_AST_new.unwrap_spec = [ObjSpace, W_Root, Arguments]
    return func_with_new_name(generic_AST_new, "new_%s" % node_class.__name__)


AST.typedef = typedef.TypeDef("AST",
    _fields=_FieldsWrapper([]),
    _attributes=_FieldsWrapper([]),
)
AST.typedef.acceptable_as_base_class = False


def missing_field(space, state, required, host):
    "Find which required field is missing."
    for i in range(len(required)):
        if not (state >> i) & 1:
            missing = required[i]
            if missing is not None:
                 err = "required attribute '%s' missing from %s"
                 err = err % (missing, host)
                 w_err = space.wrap(err)
                 raise OperationError(space.w_TypeError, w_err)
    raise AssertionError("should not reach here")


class mod(AST):

    __slots__ = ()

class Module(mod):

    __slots__ = ('body', 'w_body')


    def __init__(self, body):
        self.body = body
        self.w_body = None
        self.initialization_state = 1

    def walkabout(self, visitor):
        visitor.visit_Module(self)

    def mutate_over(self, visitor):
        if self.body:
            visitor._mutate_sequence(self.body)
        return visitor.visit_Module(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 1:
            missing_field(space, self.initialization_state, ['body'], 'Module')
        else:
            pass
        w_list = self.w_body
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.body = [space.interp_w(stmt, w_obj) for w_obj in list_w]
            else:
                self.body = None
        if self.body is not None:
            for node in self.body:
                node.sync_app_attrs(space)


class Interactive(mod):

    __slots__ = ('body', 'w_body')


    def __init__(self, body):
        self.body = body
        self.w_body = None
        self.initialization_state = 1

    def walkabout(self, visitor):
        visitor.visit_Interactive(self)

    def mutate_over(self, visitor):
        if self.body:
            visitor._mutate_sequence(self.body)
        return visitor.visit_Interactive(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 1:
            missing_field(space, self.initialization_state, ['body'], 'Interactive')
        else:
            pass
        w_list = self.w_body
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.body = [space.interp_w(stmt, w_obj) for w_obj in list_w]
            else:
                self.body = None
        if self.body is not None:
            for node in self.body:
                node.sync_app_attrs(space)


class Expression(mod):

    __slots__ = ('body')


    def __init__(self, body):
        self.body = body
        self.initialization_state = 1

    def walkabout(self, visitor):
        visitor.visit_Expression(self)

    def mutate_over(self, visitor):
        self.body = self.body.mutate_over(visitor)
        return visitor.visit_Expression(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 1:
            missing_field(space, self.initialization_state, ['body'], 'Expression')
        else:
            pass
        self.body.sync_app_attrs(space)


class Suite(mod):

    __slots__ = ('body', 'w_body')


    def __init__(self, body):
        self.body = body
        self.w_body = None
        self.initialization_state = 1

    def walkabout(self, visitor):
        visitor.visit_Suite(self)

    def mutate_over(self, visitor):
        if self.body:
            visitor._mutate_sequence(self.body)
        return visitor.visit_Suite(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 1:
            missing_field(space, self.initialization_state, ['body'], 'Suite')
        else:
            pass
        w_list = self.w_body
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.body = [space.interp_w(stmt, w_obj) for w_obj in list_w]
            else:
                self.body = None
        if self.body is not None:
            for node in self.body:
                node.sync_app_attrs(space)


class stmt(AST):

    __slots__ = ('lineno', 'col_offset')

    def __init__(self, lineno, col_offset):
        self.lineno = lineno
        self.col_offset = col_offset

class FunctionDef(stmt):

    __slots__ = ('name', 'args', 'body', 'w_body', 'decorators', 'w_decorators')

    _lineno_mask = 16
    _col_offset_mask = 32

    def __init__(self, name, args, body, decorators, lineno, col_offset):
        self.name = name
        self.args = args
        self.body = body
        self.w_body = None
        self.decorators = decorators
        self.w_decorators = None
        stmt.__init__(self, lineno, col_offset)
        self.initialization_state = 63

    def walkabout(self, visitor):
        visitor.visit_FunctionDef(self)

    def mutate_over(self, visitor):
        if self.body:
            visitor._mutate_sequence(self.body)
        if self.decorators:
            visitor._mutate_sequence(self.decorators)
        return visitor.visit_FunctionDef(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 63:
            missing_field(space, self.initialization_state, ['name', 'args', 'body', 'decorators', 'lineno', 'col_offset'], 'FunctionDef')
        else:
            pass
        self.args.sync_app_attrs(space)
        w_list = self.w_body
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.body = [space.interp_w(stmt, w_obj) for w_obj in list_w]
            else:
                self.body = None
        if self.body is not None:
            for node in self.body:
                node.sync_app_attrs(space)
        w_list = self.w_decorators
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.decorators = [space.interp_w(expr, w_obj) for w_obj in list_w]
            else:
                self.decorators = None
        if self.decorators is not None:
            for node in self.decorators:
                node.sync_app_attrs(space)


class ClassDef(stmt):

    __slots__ = ('name', 'bases', 'w_bases', 'body', 'w_body')

    _lineno_mask = 8
    _col_offset_mask = 16

    def __init__(self, name, bases, body, lineno, col_offset):
        self.name = name
        self.bases = bases
        self.w_bases = None
        self.body = body
        self.w_body = None
        stmt.__init__(self, lineno, col_offset)
        self.initialization_state = 31

    def walkabout(self, visitor):
        visitor.visit_ClassDef(self)

    def mutate_over(self, visitor):
        if self.bases:
            visitor._mutate_sequence(self.bases)
        if self.body:
            visitor._mutate_sequence(self.body)
        return visitor.visit_ClassDef(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 31:
            missing_field(space, self.initialization_state, ['name', 'bases', 'body', 'lineno', 'col_offset'], 'ClassDef')
        else:
            pass
        w_list = self.w_bases
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.bases = [space.interp_w(expr, w_obj) for w_obj in list_w]
            else:
                self.bases = None
        if self.bases is not None:
            for node in self.bases:
                node.sync_app_attrs(space)
        w_list = self.w_body
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.body = [space.interp_w(stmt, w_obj) for w_obj in list_w]
            else:
                self.body = None
        if self.body is not None:
            for node in self.body:
                node.sync_app_attrs(space)


class Return(stmt):

    __slots__ = ('value')

    _lineno_mask = 2
    _col_offset_mask = 4

    def __init__(self, value, lineno, col_offset):
        self.value = value
        stmt.__init__(self, lineno, col_offset)
        self.initialization_state = 7

    def walkabout(self, visitor):
        visitor.visit_Return(self)

    def mutate_over(self, visitor):
        if self.value:
            self.value = self.value.mutate_over(visitor)
        return visitor.visit_Return(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~1) ^ 6:
            missing_field(space, self.initialization_state, [None, 'lineno', 'col_offset'], 'Return')
        else:
            if not self.initialization_state & 1:
                self.value = None
        if self.value:
            self.value.sync_app_attrs(space)


class Delete(stmt):

    __slots__ = ('targets', 'w_targets')

    _lineno_mask = 2
    _col_offset_mask = 4

    def __init__(self, targets, lineno, col_offset):
        self.targets = targets
        self.w_targets = None
        stmt.__init__(self, lineno, col_offset)
        self.initialization_state = 7

    def walkabout(self, visitor):
        visitor.visit_Delete(self)

    def mutate_over(self, visitor):
        if self.targets:
            visitor._mutate_sequence(self.targets)
        return visitor.visit_Delete(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 7:
            missing_field(space, self.initialization_state, ['targets', 'lineno', 'col_offset'], 'Delete')
        else:
            pass
        w_list = self.w_targets
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.targets = [space.interp_w(expr, w_obj) for w_obj in list_w]
            else:
                self.targets = None
        if self.targets is not None:
            for node in self.targets:
                node.sync_app_attrs(space)


class Assign(stmt):

    __slots__ = ('targets', 'w_targets', 'value')

    _lineno_mask = 4
    _col_offset_mask = 8

    def __init__(self, targets, value, lineno, col_offset):
        self.targets = targets
        self.w_targets = None
        self.value = value
        stmt.__init__(self, lineno, col_offset)
        self.initialization_state = 15

    def walkabout(self, visitor):
        visitor.visit_Assign(self)

    def mutate_over(self, visitor):
        if self.targets:
            visitor._mutate_sequence(self.targets)
        self.value = self.value.mutate_over(visitor)
        return visitor.visit_Assign(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 15:
            missing_field(space, self.initialization_state, ['targets', 'value', 'lineno', 'col_offset'], 'Assign')
        else:
            pass
        w_list = self.w_targets
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.targets = [space.interp_w(expr, w_obj) for w_obj in list_w]
            else:
                self.targets = None
        if self.targets is not None:
            for node in self.targets:
                node.sync_app_attrs(space)
        self.value.sync_app_attrs(space)


class AugAssign(stmt):

    __slots__ = ('target', 'op', 'value')

    _lineno_mask = 8
    _col_offset_mask = 16

    def __init__(self, target, op, value, lineno, col_offset):
        self.target = target
        self.op = op
        self.value = value
        stmt.__init__(self, lineno, col_offset)
        self.initialization_state = 31

    def walkabout(self, visitor):
        visitor.visit_AugAssign(self)

    def mutate_over(self, visitor):
        self.target = self.target.mutate_over(visitor)
        self.value = self.value.mutate_over(visitor)
        return visitor.visit_AugAssign(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 31:
            missing_field(space, self.initialization_state, ['target', 'op', 'value', 'lineno', 'col_offset'], 'AugAssign')
        else:
            pass
        self.target.sync_app_attrs(space)
        self.value.sync_app_attrs(space)


class Print(stmt):

    __slots__ = ('dest', 'values', 'w_values', 'nl')

    _lineno_mask = 8
    _col_offset_mask = 16

    def __init__(self, dest, values, nl, lineno, col_offset):
        self.dest = dest
        self.values = values
        self.w_values = None
        self.nl = nl
        stmt.__init__(self, lineno, col_offset)
        self.initialization_state = 31

    def walkabout(self, visitor):
        visitor.visit_Print(self)

    def mutate_over(self, visitor):
        if self.dest:
            self.dest = self.dest.mutate_over(visitor)
        if self.values:
            visitor._mutate_sequence(self.values)
        return visitor.visit_Print(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~1) ^ 30:
            missing_field(space, self.initialization_state, [None, 'values', 'nl', 'lineno', 'col_offset'], 'Print')
        else:
            if not self.initialization_state & 1:
                self.dest = None
        if self.dest:
            self.dest.sync_app_attrs(space)
        w_list = self.w_values
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.values = [space.interp_w(expr, w_obj) for w_obj in list_w]
            else:
                self.values = None
        if self.values is not None:
            for node in self.values:
                node.sync_app_attrs(space)


class For(stmt):

    __slots__ = ('target', 'iter', 'body', 'w_body', 'orelse', 'w_orelse')

    _lineno_mask = 16
    _col_offset_mask = 32

    def __init__(self, target, iter, body, orelse, lineno, col_offset):
        self.target = target
        self.iter = iter
        self.body = body
        self.w_body = None
        self.orelse = orelse
        self.w_orelse = None
        stmt.__init__(self, lineno, col_offset)
        self.initialization_state = 63

    def walkabout(self, visitor):
        visitor.visit_For(self)

    def mutate_over(self, visitor):
        self.target = self.target.mutate_over(visitor)
        self.iter = self.iter.mutate_over(visitor)
        if self.body:
            visitor._mutate_sequence(self.body)
        if self.orelse:
            visitor._mutate_sequence(self.orelse)
        return visitor.visit_For(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 63:
            missing_field(space, self.initialization_state, ['target', 'iter', 'body', 'orelse', 'lineno', 'col_offset'], 'For')
        else:
            pass
        self.target.sync_app_attrs(space)
        self.iter.sync_app_attrs(space)
        w_list = self.w_body
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.body = [space.interp_w(stmt, w_obj) for w_obj in list_w]
            else:
                self.body = None
        if self.body is not None:
            for node in self.body:
                node.sync_app_attrs(space)
        w_list = self.w_orelse
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.orelse = [space.interp_w(stmt, w_obj) for w_obj in list_w]
            else:
                self.orelse = None
        if self.orelse is not None:
            for node in self.orelse:
                node.sync_app_attrs(space)


class While(stmt):

    __slots__ = ('test', 'body', 'w_body', 'orelse', 'w_orelse')

    _lineno_mask = 8
    _col_offset_mask = 16

    def __init__(self, test, body, orelse, lineno, col_offset):
        self.test = test
        self.body = body
        self.w_body = None
        self.orelse = orelse
        self.w_orelse = None
        stmt.__init__(self, lineno, col_offset)
        self.initialization_state = 31

    def walkabout(self, visitor):
        visitor.visit_While(self)

    def mutate_over(self, visitor):
        self.test = self.test.mutate_over(visitor)
        if self.body:
            visitor._mutate_sequence(self.body)
        if self.orelse:
            visitor._mutate_sequence(self.orelse)
        return visitor.visit_While(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 31:
            missing_field(space, self.initialization_state, ['test', 'body', 'orelse', 'lineno', 'col_offset'], 'While')
        else:
            pass
        self.test.sync_app_attrs(space)
        w_list = self.w_body
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.body = [space.interp_w(stmt, w_obj) for w_obj in list_w]
            else:
                self.body = None
        if self.body is not None:
            for node in self.body:
                node.sync_app_attrs(space)
        w_list = self.w_orelse
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.orelse = [space.interp_w(stmt, w_obj) for w_obj in list_w]
            else:
                self.orelse = None
        if self.orelse is not None:
            for node in self.orelse:
                node.sync_app_attrs(space)


class If(stmt):

    __slots__ = ('test', 'body', 'w_body', 'orelse', 'w_orelse')

    _lineno_mask = 8
    _col_offset_mask = 16

    def __init__(self, test, body, orelse, lineno, col_offset):
        self.test = test
        self.body = body
        self.w_body = None
        self.orelse = orelse
        self.w_orelse = None
        stmt.__init__(self, lineno, col_offset)
        self.initialization_state = 31

    def walkabout(self, visitor):
        visitor.visit_If(self)

    def mutate_over(self, visitor):
        self.test = self.test.mutate_over(visitor)
        if self.body:
            visitor._mutate_sequence(self.body)
        if self.orelse:
            visitor._mutate_sequence(self.orelse)
        return visitor.visit_If(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 31:
            missing_field(space, self.initialization_state, ['test', 'body', 'orelse', 'lineno', 'col_offset'], 'If')
        else:
            pass
        self.test.sync_app_attrs(space)
        w_list = self.w_body
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.body = [space.interp_w(stmt, w_obj) for w_obj in list_w]
            else:
                self.body = None
        if self.body is not None:
            for node in self.body:
                node.sync_app_attrs(space)
        w_list = self.w_orelse
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.orelse = [space.interp_w(stmt, w_obj) for w_obj in list_w]
            else:
                self.orelse = None
        if self.orelse is not None:
            for node in self.orelse:
                node.sync_app_attrs(space)


class With(stmt):

    __slots__ = ('context_expr', 'optional_vars', 'body', 'w_body')

    _lineno_mask = 8
    _col_offset_mask = 16

    def __init__(self, context_expr, optional_vars, body, lineno, col_offset):
        self.context_expr = context_expr
        self.optional_vars = optional_vars
        self.body = body
        self.w_body = None
        stmt.__init__(self, lineno, col_offset)
        self.initialization_state = 31

    def walkabout(self, visitor):
        visitor.visit_With(self)

    def mutate_over(self, visitor):
        self.context_expr = self.context_expr.mutate_over(visitor)
        if self.optional_vars:
            self.optional_vars = self.optional_vars.mutate_over(visitor)
        if self.body:
            visitor._mutate_sequence(self.body)
        return visitor.visit_With(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~2) ^ 29:
            missing_field(space, self.initialization_state, ['context_expr', None, 'body', 'lineno', 'col_offset'], 'With')
        else:
            if not self.initialization_state & 2:
                self.optional_vars = None
        self.context_expr.sync_app_attrs(space)
        if self.optional_vars:
            self.optional_vars.sync_app_attrs(space)
        w_list = self.w_body
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.body = [space.interp_w(stmt, w_obj) for w_obj in list_w]
            else:
                self.body = None
        if self.body is not None:
            for node in self.body:
                node.sync_app_attrs(space)


class Raise(stmt):

    __slots__ = ('type', 'inst', 'tback')

    _lineno_mask = 8
    _col_offset_mask = 16

    def __init__(self, type, inst, tback, lineno, col_offset):
        self.type = type
        self.inst = inst
        self.tback = tback
        stmt.__init__(self, lineno, col_offset)
        self.initialization_state = 31

    def walkabout(self, visitor):
        visitor.visit_Raise(self)

    def mutate_over(self, visitor):
        if self.type:
            self.type = self.type.mutate_over(visitor)
        if self.inst:
            self.inst = self.inst.mutate_over(visitor)
        if self.tback:
            self.tback = self.tback.mutate_over(visitor)
        return visitor.visit_Raise(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~7) ^ 24:
            missing_field(space, self.initialization_state, [None, None, None, 'lineno', 'col_offset'], 'Raise')
        else:
            if not self.initialization_state & 1:
                self.type = None
            if not self.initialization_state & 2:
                self.inst = None
            if not self.initialization_state & 4:
                self.tback = None
        if self.type:
            self.type.sync_app_attrs(space)
        if self.inst:
            self.inst.sync_app_attrs(space)
        if self.tback:
            self.tback.sync_app_attrs(space)


class TryExcept(stmt):

    __slots__ = ('body', 'w_body', 'handlers', 'w_handlers', 'orelse', 'w_orelse')

    _lineno_mask = 8
    _col_offset_mask = 16

    def __init__(self, body, handlers, orelse, lineno, col_offset):
        self.body = body
        self.w_body = None
        self.handlers = handlers
        self.w_handlers = None
        self.orelse = orelse
        self.w_orelse = None
        stmt.__init__(self, lineno, col_offset)
        self.initialization_state = 31

    def walkabout(self, visitor):
        visitor.visit_TryExcept(self)

    def mutate_over(self, visitor):
        if self.body:
            visitor._mutate_sequence(self.body)
        if self.orelse:
            visitor._mutate_sequence(self.orelse)
        return visitor.visit_TryExcept(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 31:
            missing_field(space, self.initialization_state, ['body', 'handlers', 'orelse', 'lineno', 'col_offset'], 'TryExcept')
        else:
            pass
        w_list = self.w_body
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.body = [space.interp_w(stmt, w_obj) for w_obj in list_w]
            else:
                self.body = None
        if self.body is not None:
            for node in self.body:
                node.sync_app_attrs(space)
        w_list = self.w_handlers
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.handlers = [space.interp_w(excepthandler, w_obj) for w_obj in list_w]
            else:
                self.handlers = None
        if self.handlers is not None:
            for node in self.handlers:
                node.sync_app_attrs(space)
        w_list = self.w_orelse
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.orelse = [space.interp_w(stmt, w_obj) for w_obj in list_w]
            else:
                self.orelse = None
        if self.orelse is not None:
            for node in self.orelse:
                node.sync_app_attrs(space)


class TryFinally(stmt):

    __slots__ = ('body', 'w_body', 'finalbody', 'w_finalbody')

    _lineno_mask = 4
    _col_offset_mask = 8

    def __init__(self, body, finalbody, lineno, col_offset):
        self.body = body
        self.w_body = None
        self.finalbody = finalbody
        self.w_finalbody = None
        stmt.__init__(self, lineno, col_offset)
        self.initialization_state = 15

    def walkabout(self, visitor):
        visitor.visit_TryFinally(self)

    def mutate_over(self, visitor):
        if self.body:
            visitor._mutate_sequence(self.body)
        if self.finalbody:
            visitor._mutate_sequence(self.finalbody)
        return visitor.visit_TryFinally(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 15:
            missing_field(space, self.initialization_state, ['body', 'finalbody', 'lineno', 'col_offset'], 'TryFinally')
        else:
            pass
        w_list = self.w_body
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.body = [space.interp_w(stmt, w_obj) for w_obj in list_w]
            else:
                self.body = None
        if self.body is not None:
            for node in self.body:
                node.sync_app_attrs(space)
        w_list = self.w_finalbody
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.finalbody = [space.interp_w(stmt, w_obj) for w_obj in list_w]
            else:
                self.finalbody = None
        if self.finalbody is not None:
            for node in self.finalbody:
                node.sync_app_attrs(space)


class Assert(stmt):

    __slots__ = ('test', 'msg')

    _lineno_mask = 4
    _col_offset_mask = 8

    def __init__(self, test, msg, lineno, col_offset):
        self.test = test
        self.msg = msg
        stmt.__init__(self, lineno, col_offset)
        self.initialization_state = 15

    def walkabout(self, visitor):
        visitor.visit_Assert(self)

    def mutate_over(self, visitor):
        self.test = self.test.mutate_over(visitor)
        if self.msg:
            self.msg = self.msg.mutate_over(visitor)
        return visitor.visit_Assert(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~2) ^ 13:
            missing_field(space, self.initialization_state, ['test', None, 'lineno', 'col_offset'], 'Assert')
        else:
            if not self.initialization_state & 2:
                self.msg = None
        self.test.sync_app_attrs(space)
        if self.msg:
            self.msg.sync_app_attrs(space)


class Import(stmt):

    __slots__ = ('names', 'w_names')

    _lineno_mask = 2
    _col_offset_mask = 4

    def __init__(self, names, lineno, col_offset):
        self.names = names
        self.w_names = None
        stmt.__init__(self, lineno, col_offset)
        self.initialization_state = 7

    def walkabout(self, visitor):
        visitor.visit_Import(self)

    def mutate_over(self, visitor):
        return visitor.visit_Import(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 7:
            missing_field(space, self.initialization_state, ['names', 'lineno', 'col_offset'], 'Import')
        else:
            pass
        w_list = self.w_names
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.names = [space.interp_w(alias, w_obj) for w_obj in list_w]
            else:
                self.names = None
        if self.names is not None:
            for node in self.names:
                node.sync_app_attrs(space)


class ImportFrom(stmt):

    __slots__ = ('module', 'names', 'w_names', 'level')

    _lineno_mask = 8
    _col_offset_mask = 16

    def __init__(self, module, names, level, lineno, col_offset):
        self.module = module
        self.names = names
        self.w_names = None
        self.level = level
        stmt.__init__(self, lineno, col_offset)
        self.initialization_state = 31

    def walkabout(self, visitor):
        visitor.visit_ImportFrom(self)

    def mutate_over(self, visitor):
        return visitor.visit_ImportFrom(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~5) ^ 26:
            missing_field(space, self.initialization_state, [None, 'names', None, 'lineno', 'col_offset'], 'ImportFrom')
        else:
            if not self.initialization_state & 1:
                self.module = None
            if not self.initialization_state & 4:
                self.level = 0
        w_list = self.w_names
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.names = [space.interp_w(alias, w_obj) for w_obj in list_w]
            else:
                self.names = None
        if self.names is not None:
            for node in self.names:
                node.sync_app_attrs(space)


class Exec(stmt):

    __slots__ = ('body', 'globals', 'locals')

    _lineno_mask = 8
    _col_offset_mask = 16

    def __init__(self, body, globals, locals, lineno, col_offset):
        self.body = body
        self.globals = globals
        self.locals = locals
        stmt.__init__(self, lineno, col_offset)
        self.initialization_state = 31

    def walkabout(self, visitor):
        visitor.visit_Exec(self)

    def mutate_over(self, visitor):
        self.body = self.body.mutate_over(visitor)
        if self.globals:
            self.globals = self.globals.mutate_over(visitor)
        if self.locals:
            self.locals = self.locals.mutate_over(visitor)
        return visitor.visit_Exec(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~6) ^ 25:
            missing_field(space, self.initialization_state, ['body', None, None, 'lineno', 'col_offset'], 'Exec')
        else:
            if not self.initialization_state & 2:
                self.globals = None
            if not self.initialization_state & 4:
                self.locals = None
        self.body.sync_app_attrs(space)
        if self.globals:
            self.globals.sync_app_attrs(space)
        if self.locals:
            self.locals.sync_app_attrs(space)


class Global(stmt):

    __slots__ = ('names', 'w_names')

    _lineno_mask = 2
    _col_offset_mask = 4

    def __init__(self, names, lineno, col_offset):
        self.names = names
        self.w_names = None
        stmt.__init__(self, lineno, col_offset)
        self.initialization_state = 7

    def walkabout(self, visitor):
        visitor.visit_Global(self)

    def mutate_over(self, visitor):
        return visitor.visit_Global(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 7:
            missing_field(space, self.initialization_state, ['names', 'lineno', 'col_offset'], 'Global')
        else:
            pass
        w_list = self.w_names
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.names = [space.str_w(w_obj) for w_obj in list_w]
            else:
                self.names = None


class Expr(stmt):

    __slots__ = ('value')

    _lineno_mask = 2
    _col_offset_mask = 4

    def __init__(self, value, lineno, col_offset):
        self.value = value
        stmt.__init__(self, lineno, col_offset)
        self.initialization_state = 7

    def walkabout(self, visitor):
        visitor.visit_Expr(self)

    def mutate_over(self, visitor):
        self.value = self.value.mutate_over(visitor)
        return visitor.visit_Expr(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 7:
            missing_field(space, self.initialization_state, ['value', 'lineno', 'col_offset'], 'Expr')
        else:
            pass
        self.value.sync_app_attrs(space)


class Pass(stmt):

    __slots__ = ()

    _lineno_mask = 1
    _col_offset_mask = 2

    def __init__(self, lineno, col_offset):
        stmt.__init__(self, lineno, col_offset)
        self.initialization_state = 3

    def walkabout(self, visitor):
        visitor.visit_Pass(self)

    def mutate_over(self, visitor):
        return visitor.visit_Pass(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 3:
            missing_field(space, self.initialization_state, ['lineno', 'col_offset'], 'Pass')
        else:
            pass


class Break(stmt):

    __slots__ = ()

    _lineno_mask = 1
    _col_offset_mask = 2

    def __init__(self, lineno, col_offset):
        stmt.__init__(self, lineno, col_offset)
        self.initialization_state = 3

    def walkabout(self, visitor):
        visitor.visit_Break(self)

    def mutate_over(self, visitor):
        return visitor.visit_Break(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 3:
            missing_field(space, self.initialization_state, ['lineno', 'col_offset'], 'Break')
        else:
            pass


class Continue(stmt):

    __slots__ = ()

    _lineno_mask = 1
    _col_offset_mask = 2

    def __init__(self, lineno, col_offset):
        stmt.__init__(self, lineno, col_offset)
        self.initialization_state = 3

    def walkabout(self, visitor):
        visitor.visit_Continue(self)

    def mutate_over(self, visitor):
        return visitor.visit_Continue(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 3:
            missing_field(space, self.initialization_state, ['lineno', 'col_offset'], 'Continue')
        else:
            pass


class expr(AST):

    __slots__ = ('lineno', 'col_offset')

    def __init__(self, lineno, col_offset):
        self.lineno = lineno
        self.col_offset = col_offset

class BoolOp(expr):

    __slots__ = ('op', 'values', 'w_values')

    _lineno_mask = 4
    _col_offset_mask = 8

    def __init__(self, op, values, lineno, col_offset):
        self.op = op
        self.values = values
        self.w_values = None
        expr.__init__(self, lineno, col_offset)
        self.initialization_state = 15

    def walkabout(self, visitor):
        visitor.visit_BoolOp(self)

    def mutate_over(self, visitor):
        if self.values:
            visitor._mutate_sequence(self.values)
        return visitor.visit_BoolOp(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 15:
            missing_field(space, self.initialization_state, ['op', 'values', 'lineno', 'col_offset'], 'BoolOp')
        else:
            pass
        w_list = self.w_values
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.values = [space.interp_w(expr, w_obj) for w_obj in list_w]
            else:
                self.values = None
        if self.values is not None:
            for node in self.values:
                node.sync_app_attrs(space)


class BinOp(expr):

    __slots__ = ('left', 'op', 'right')

    _lineno_mask = 8
    _col_offset_mask = 16

    def __init__(self, left, op, right, lineno, col_offset):
        self.left = left
        self.op = op
        self.right = right
        expr.__init__(self, lineno, col_offset)
        self.initialization_state = 31

    def walkabout(self, visitor):
        visitor.visit_BinOp(self)

    def mutate_over(self, visitor):
        self.left = self.left.mutate_over(visitor)
        self.right = self.right.mutate_over(visitor)
        return visitor.visit_BinOp(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 31:
            missing_field(space, self.initialization_state, ['left', 'op', 'right', 'lineno', 'col_offset'], 'BinOp')
        else:
            pass
        self.left.sync_app_attrs(space)
        self.right.sync_app_attrs(space)


class UnaryOp(expr):

    __slots__ = ('op', 'operand')

    _lineno_mask = 4
    _col_offset_mask = 8

    def __init__(self, op, operand, lineno, col_offset):
        self.op = op
        self.operand = operand
        expr.__init__(self, lineno, col_offset)
        self.initialization_state = 15

    def walkabout(self, visitor):
        visitor.visit_UnaryOp(self)

    def mutate_over(self, visitor):
        self.operand = self.operand.mutate_over(visitor)
        return visitor.visit_UnaryOp(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 15:
            missing_field(space, self.initialization_state, ['op', 'operand', 'lineno', 'col_offset'], 'UnaryOp')
        else:
            pass
        self.operand.sync_app_attrs(space)


class Lambda(expr):

    __slots__ = ('args', 'body')

    _lineno_mask = 4
    _col_offset_mask = 8

    def __init__(self, args, body, lineno, col_offset):
        self.args = args
        self.body = body
        expr.__init__(self, lineno, col_offset)
        self.initialization_state = 15

    def walkabout(self, visitor):
        visitor.visit_Lambda(self)

    def mutate_over(self, visitor):
        self.body = self.body.mutate_over(visitor)
        return visitor.visit_Lambda(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 15:
            missing_field(space, self.initialization_state, ['args', 'body', 'lineno', 'col_offset'], 'Lambda')
        else:
            pass
        self.args.sync_app_attrs(space)
        self.body.sync_app_attrs(space)


class IfExp(expr):

    __slots__ = ('test', 'body', 'orelse')

    _lineno_mask = 8
    _col_offset_mask = 16

    def __init__(self, test, body, orelse, lineno, col_offset):
        self.test = test
        self.body = body
        self.orelse = orelse
        expr.__init__(self, lineno, col_offset)
        self.initialization_state = 31

    def walkabout(self, visitor):
        visitor.visit_IfExp(self)

    def mutate_over(self, visitor):
        self.test = self.test.mutate_over(visitor)
        self.body = self.body.mutate_over(visitor)
        self.orelse = self.orelse.mutate_over(visitor)
        return visitor.visit_IfExp(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 31:
            missing_field(space, self.initialization_state, ['test', 'body', 'orelse', 'lineno', 'col_offset'], 'IfExp')
        else:
            pass
        self.test.sync_app_attrs(space)
        self.body.sync_app_attrs(space)
        self.orelse.sync_app_attrs(space)


class Dict(expr):

    __slots__ = ('keys', 'w_keys', 'values', 'w_values')

    _lineno_mask = 4
    _col_offset_mask = 8

    def __init__(self, keys, values, lineno, col_offset):
        self.keys = keys
        self.w_keys = None
        self.values = values
        self.w_values = None
        expr.__init__(self, lineno, col_offset)
        self.initialization_state = 15

    def walkabout(self, visitor):
        visitor.visit_Dict(self)

    def mutate_over(self, visitor):
        if self.keys:
            visitor._mutate_sequence(self.keys)
        if self.values:
            visitor._mutate_sequence(self.values)
        return visitor.visit_Dict(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 15:
            missing_field(space, self.initialization_state, ['keys', 'values', 'lineno', 'col_offset'], 'Dict')
        else:
            pass
        w_list = self.w_keys
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.keys = [space.interp_w(expr, w_obj) for w_obj in list_w]
            else:
                self.keys = None
        if self.keys is not None:
            for node in self.keys:
                node.sync_app_attrs(space)
        w_list = self.w_values
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.values = [space.interp_w(expr, w_obj) for w_obj in list_w]
            else:
                self.values = None
        if self.values is not None:
            for node in self.values:
                node.sync_app_attrs(space)


class ListComp(expr):

    __slots__ = ('elt', 'generators', 'w_generators')

    _lineno_mask = 4
    _col_offset_mask = 8

    def __init__(self, elt, generators, lineno, col_offset):
        self.elt = elt
        self.generators = generators
        self.w_generators = None
        expr.__init__(self, lineno, col_offset)
        self.initialization_state = 15

    def walkabout(self, visitor):
        visitor.visit_ListComp(self)

    def mutate_over(self, visitor):
        self.elt = self.elt.mutate_over(visitor)
        return visitor.visit_ListComp(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 15:
            missing_field(space, self.initialization_state, ['elt', 'generators', 'lineno', 'col_offset'], 'ListComp')
        else:
            pass
        self.elt.sync_app_attrs(space)
        w_list = self.w_generators
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.generators = [space.interp_w(comprehension, w_obj) for w_obj in list_w]
            else:
                self.generators = None
        if self.generators is not None:
            for node in self.generators:
                node.sync_app_attrs(space)


class GeneratorExp(expr):

    __slots__ = ('elt', 'generators', 'w_generators')

    _lineno_mask = 4
    _col_offset_mask = 8

    def __init__(self, elt, generators, lineno, col_offset):
        self.elt = elt
        self.generators = generators
        self.w_generators = None
        expr.__init__(self, lineno, col_offset)
        self.initialization_state = 15

    def walkabout(self, visitor):
        visitor.visit_GeneratorExp(self)

    def mutate_over(self, visitor):
        self.elt = self.elt.mutate_over(visitor)
        return visitor.visit_GeneratorExp(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 15:
            missing_field(space, self.initialization_state, ['elt', 'generators', 'lineno', 'col_offset'], 'GeneratorExp')
        else:
            pass
        self.elt.sync_app_attrs(space)
        w_list = self.w_generators
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.generators = [space.interp_w(comprehension, w_obj) for w_obj in list_w]
            else:
                self.generators = None
        if self.generators is not None:
            for node in self.generators:
                node.sync_app_attrs(space)


class Yield(expr):

    __slots__ = ('value')

    _lineno_mask = 2
    _col_offset_mask = 4

    def __init__(self, value, lineno, col_offset):
        self.value = value
        expr.__init__(self, lineno, col_offset)
        self.initialization_state = 7

    def walkabout(self, visitor):
        visitor.visit_Yield(self)

    def mutate_over(self, visitor):
        if self.value:
            self.value = self.value.mutate_over(visitor)
        return visitor.visit_Yield(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~1) ^ 6:
            missing_field(space, self.initialization_state, [None, 'lineno', 'col_offset'], 'Yield')
        else:
            if not self.initialization_state & 1:
                self.value = None
        if self.value:
            self.value.sync_app_attrs(space)


class Compare(expr):

    __slots__ = ('left', 'ops', 'w_ops', 'comparators', 'w_comparators')

    _lineno_mask = 8
    _col_offset_mask = 16

    def __init__(self, left, ops, comparators, lineno, col_offset):
        self.left = left
        self.ops = ops
        self.w_ops = None
        self.comparators = comparators
        self.w_comparators = None
        expr.__init__(self, lineno, col_offset)
        self.initialization_state = 31

    def walkabout(self, visitor):
        visitor.visit_Compare(self)

    def mutate_over(self, visitor):
        self.left = self.left.mutate_over(visitor)
        if self.comparators:
            visitor._mutate_sequence(self.comparators)
        return visitor.visit_Compare(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 31:
            missing_field(space, self.initialization_state, ['left', 'ops', 'comparators', 'lineno', 'col_offset'], 'Compare')
        else:
            pass
        self.left.sync_app_attrs(space)
        w_list = self.w_ops
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.ops = [space.interp_w(cmpop, w_obj).to_simple_int(space) for w_obj in list_w]
            else:
                self.ops = None
        w_list = self.w_comparators
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.comparators = [space.interp_w(expr, w_obj) for w_obj in list_w]
            else:
                self.comparators = None
        if self.comparators is not None:
            for node in self.comparators:
                node.sync_app_attrs(space)


class Call(expr):

    __slots__ = ('func', 'args', 'w_args', 'keywords', 'w_keywords', 'starargs', 'kwargs')

    _lineno_mask = 32
    _col_offset_mask = 64

    def __init__(self, func, args, keywords, starargs, kwargs, lineno, col_offset):
        self.func = func
        self.args = args
        self.w_args = None
        self.keywords = keywords
        self.w_keywords = None
        self.starargs = starargs
        self.kwargs = kwargs
        expr.__init__(self, lineno, col_offset)
        self.initialization_state = 127

    def walkabout(self, visitor):
        visitor.visit_Call(self)

    def mutate_over(self, visitor):
        self.func = self.func.mutate_over(visitor)
        if self.args:
            visitor._mutate_sequence(self.args)
        if self.starargs:
            self.starargs = self.starargs.mutate_over(visitor)
        if self.kwargs:
            self.kwargs = self.kwargs.mutate_over(visitor)
        return visitor.visit_Call(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~24) ^ 103:
            missing_field(space, self.initialization_state, ['func', 'args', 'keywords', None, None, 'lineno', 'col_offset'], 'Call')
        else:
            if not self.initialization_state & 8:
                self.starargs = None
            if not self.initialization_state & 16:
                self.kwargs = None
        self.func.sync_app_attrs(space)
        w_list = self.w_args
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.args = [space.interp_w(expr, w_obj) for w_obj in list_w]
            else:
                self.args = None
        if self.args is not None:
            for node in self.args:
                node.sync_app_attrs(space)
        w_list = self.w_keywords
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.keywords = [space.interp_w(keyword, w_obj) for w_obj in list_w]
            else:
                self.keywords = None
        if self.keywords is not None:
            for node in self.keywords:
                node.sync_app_attrs(space)
        if self.starargs:
            self.starargs.sync_app_attrs(space)
        if self.kwargs:
            self.kwargs.sync_app_attrs(space)


class Repr(expr):

    __slots__ = ('value')

    _lineno_mask = 2
    _col_offset_mask = 4

    def __init__(self, value, lineno, col_offset):
        self.value = value
        expr.__init__(self, lineno, col_offset)
        self.initialization_state = 7

    def walkabout(self, visitor):
        visitor.visit_Repr(self)

    def mutate_over(self, visitor):
        self.value = self.value.mutate_over(visitor)
        return visitor.visit_Repr(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 7:
            missing_field(space, self.initialization_state, ['value', 'lineno', 'col_offset'], 'Repr')
        else:
            pass
        self.value.sync_app_attrs(space)


class Num(expr):

    __slots__ = ('n')

    _lineno_mask = 2
    _col_offset_mask = 4

    def __init__(self, n, lineno, col_offset):
        self.n = n
        expr.__init__(self, lineno, col_offset)
        self.initialization_state = 7

    def walkabout(self, visitor):
        visitor.visit_Num(self)

    def mutate_over(self, visitor):
        return visitor.visit_Num(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 7:
            missing_field(space, self.initialization_state, ['n', 'lineno', 'col_offset'], 'Num')
        else:
            pass


class Str(expr):

    __slots__ = ('s')

    _lineno_mask = 2
    _col_offset_mask = 4

    def __init__(self, s, lineno, col_offset):
        self.s = s
        expr.__init__(self, lineno, col_offset)
        self.initialization_state = 7

    def walkabout(self, visitor):
        visitor.visit_Str(self)

    def mutate_over(self, visitor):
        return visitor.visit_Str(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 7:
            missing_field(space, self.initialization_state, ['s', 'lineno', 'col_offset'], 'Str')
        else:
            pass


class Attribute(expr):

    __slots__ = ('value', 'attr', 'ctx')

    _lineno_mask = 8
    _col_offset_mask = 16

    def __init__(self, value, attr, ctx, lineno, col_offset):
        self.value = value
        self.attr = attr
        self.ctx = ctx
        expr.__init__(self, lineno, col_offset)
        self.initialization_state = 31

    def walkabout(self, visitor):
        visitor.visit_Attribute(self)

    def mutate_over(self, visitor):
        self.value = self.value.mutate_over(visitor)
        return visitor.visit_Attribute(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 31:
            missing_field(space, self.initialization_state, ['value', 'attr', 'ctx', 'lineno', 'col_offset'], 'Attribute')
        else:
            pass
        self.value.sync_app_attrs(space)


class Subscript(expr):

    __slots__ = ('value', 'slice', 'ctx')

    _lineno_mask = 8
    _col_offset_mask = 16

    def __init__(self, value, slice, ctx, lineno, col_offset):
        self.value = value
        self.slice = slice
        self.ctx = ctx
        expr.__init__(self, lineno, col_offset)
        self.initialization_state = 31

    def walkabout(self, visitor):
        visitor.visit_Subscript(self)

    def mutate_over(self, visitor):
        self.value = self.value.mutate_over(visitor)
        self.slice = self.slice.mutate_over(visitor)
        return visitor.visit_Subscript(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 31:
            missing_field(space, self.initialization_state, ['value', 'slice', 'ctx', 'lineno', 'col_offset'], 'Subscript')
        else:
            pass
        self.value.sync_app_attrs(space)
        self.slice.sync_app_attrs(space)


class Name(expr):

    __slots__ = ('id', 'ctx')

    _lineno_mask = 4
    _col_offset_mask = 8

    def __init__(self, id, ctx, lineno, col_offset):
        self.id = id
        self.ctx = ctx
        expr.__init__(self, lineno, col_offset)
        self.initialization_state = 15

    def walkabout(self, visitor):
        visitor.visit_Name(self)

    def mutate_over(self, visitor):
        return visitor.visit_Name(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 15:
            missing_field(space, self.initialization_state, ['id', 'ctx', 'lineno', 'col_offset'], 'Name')
        else:
            pass


class List(expr):

    __slots__ = ('elts', 'w_elts', 'ctx')

    _lineno_mask = 4
    _col_offset_mask = 8

    def __init__(self, elts, ctx, lineno, col_offset):
        self.elts = elts
        self.w_elts = None
        self.ctx = ctx
        expr.__init__(self, lineno, col_offset)
        self.initialization_state = 15

    def walkabout(self, visitor):
        visitor.visit_List(self)

    def mutate_over(self, visitor):
        if self.elts:
            visitor._mutate_sequence(self.elts)
        return visitor.visit_List(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 15:
            missing_field(space, self.initialization_state, ['elts', 'ctx', 'lineno', 'col_offset'], 'List')
        else:
            pass
        w_list = self.w_elts
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.elts = [space.interp_w(expr, w_obj) for w_obj in list_w]
            else:
                self.elts = None
        if self.elts is not None:
            for node in self.elts:
                node.sync_app_attrs(space)


class Tuple(expr):

    __slots__ = ('elts', 'w_elts', 'ctx')

    _lineno_mask = 4
    _col_offset_mask = 8

    def __init__(self, elts, ctx, lineno, col_offset):
        self.elts = elts
        self.w_elts = None
        self.ctx = ctx
        expr.__init__(self, lineno, col_offset)
        self.initialization_state = 15

    def walkabout(self, visitor):
        visitor.visit_Tuple(self)

    def mutate_over(self, visitor):
        if self.elts:
            visitor._mutate_sequence(self.elts)
        return visitor.visit_Tuple(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 15:
            missing_field(space, self.initialization_state, ['elts', 'ctx', 'lineno', 'col_offset'], 'Tuple')
        else:
            pass
        w_list = self.w_elts
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.elts = [space.interp_w(expr, w_obj) for w_obj in list_w]
            else:
                self.elts = None
        if self.elts is not None:
            for node in self.elts:
                node.sync_app_attrs(space)


class Const(expr):

    __slots__ = ('value')

    _lineno_mask = 2
    _col_offset_mask = 4

    def __init__(self, value, lineno, col_offset):
        self.value = value
        expr.__init__(self, lineno, col_offset)
        self.initialization_state = 7

    def walkabout(self, visitor):
        visitor.visit_Const(self)

    def mutate_over(self, visitor):
        return visitor.visit_Const(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 7:
            missing_field(space, self.initialization_state, ['value', 'lineno', 'col_offset'], 'Const')
        else:
            pass


class expr_context(AST):

    def to_simple_int(self, space):
        w_msg = space.wrap("not a valid expr_context")
        raise OperationError(space.w_TypeError, w_msg)

class _Load(expr_context):

    def to_simple_int(self, space):
        return 1

class _Store(expr_context):

    def to_simple_int(self, space):
        return 2

class _Del(expr_context):

    def to_simple_int(self, space):
        return 3

class _AugLoad(expr_context):

    def to_simple_int(self, space):
        return 4

class _AugStore(expr_context):

    def to_simple_int(self, space):
        return 5

class _Param(expr_context):

    def to_simple_int(self, space):
        return 6

Load = 1
Store = 2
Del = 3
AugLoad = 4
AugStore = 5
Param = 6

expr_context_to_class = [
    _Load,
    _Store,
    _Del,
    _AugLoad,
    _AugStore,
    _Param,
]

class slice(AST):

    __slots__ = ()

class Ellipsis(slice):

    __slots__ = ()


    def __init__(self):
        self.initialization_state = 0

    def walkabout(self, visitor):
        visitor.visit_Ellipsis(self)

    def mutate_over(self, visitor):
        return visitor.visit_Ellipsis(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 0:
            missing_field(space, self.initialization_state, [], 'Ellipsis')
        else:
            pass


class Slice(slice):

    __slots__ = ('lower', 'upper', 'step')


    def __init__(self, lower, upper, step):
        self.lower = lower
        self.upper = upper
        self.step = step
        self.initialization_state = 7

    def walkabout(self, visitor):
        visitor.visit_Slice(self)

    def mutate_over(self, visitor):
        if self.lower:
            self.lower = self.lower.mutate_over(visitor)
        if self.upper:
            self.upper = self.upper.mutate_over(visitor)
        if self.step:
            self.step = self.step.mutate_over(visitor)
        return visitor.visit_Slice(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~7) ^ 0:
            missing_field(space, self.initialization_state, [None, None, None], 'Slice')
        else:
            if not self.initialization_state & 1:
                self.lower = None
            if not self.initialization_state & 2:
                self.upper = None
            if not self.initialization_state & 4:
                self.step = None
        if self.lower:
            self.lower.sync_app_attrs(space)
        if self.upper:
            self.upper.sync_app_attrs(space)
        if self.step:
            self.step.sync_app_attrs(space)


class ExtSlice(slice):

    __slots__ = ('dims', 'w_dims')


    def __init__(self, dims):
        self.dims = dims
        self.w_dims = None
        self.initialization_state = 1

    def walkabout(self, visitor):
        visitor.visit_ExtSlice(self)

    def mutate_over(self, visitor):
        if self.dims:
            visitor._mutate_sequence(self.dims)
        return visitor.visit_ExtSlice(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 1:
            missing_field(space, self.initialization_state, ['dims'], 'ExtSlice')
        else:
            pass
        w_list = self.w_dims
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.dims = [space.interp_w(slice, w_obj) for w_obj in list_w]
            else:
                self.dims = None
        if self.dims is not None:
            for node in self.dims:
                node.sync_app_attrs(space)


class Index(slice):

    __slots__ = ('value')


    def __init__(self, value):
        self.value = value
        self.initialization_state = 1

    def walkabout(self, visitor):
        visitor.visit_Index(self)

    def mutate_over(self, visitor):
        self.value = self.value.mutate_over(visitor)
        return visitor.visit_Index(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 1:
            missing_field(space, self.initialization_state, ['value'], 'Index')
        else:
            pass
        self.value.sync_app_attrs(space)


class boolop(AST):

    def to_simple_int(self, space):
        w_msg = space.wrap("not a valid boolop")
        raise OperationError(space.w_TypeError, w_msg)

class _And(boolop):

    def to_simple_int(self, space):
        return 1

class _Or(boolop):

    def to_simple_int(self, space):
        return 2

And = 1
Or = 2

boolop_to_class = [
    _And,
    _Or,
]

class operator(AST):

    def to_simple_int(self, space):
        w_msg = space.wrap("not a valid operator")
        raise OperationError(space.w_TypeError, w_msg)

class _Add(operator):

    def to_simple_int(self, space):
        return 1

class _Sub(operator):

    def to_simple_int(self, space):
        return 2

class _Mult(operator):

    def to_simple_int(self, space):
        return 3

class _Div(operator):

    def to_simple_int(self, space):
        return 4

class _Mod(operator):

    def to_simple_int(self, space):
        return 5

class _Pow(operator):

    def to_simple_int(self, space):
        return 6

class _LShift(operator):

    def to_simple_int(self, space):
        return 7

class _RShift(operator):

    def to_simple_int(self, space):
        return 8

class _BitOr(operator):

    def to_simple_int(self, space):
        return 9

class _BitXor(operator):

    def to_simple_int(self, space):
        return 10

class _BitAnd(operator):

    def to_simple_int(self, space):
        return 11

class _FloorDiv(operator):

    def to_simple_int(self, space):
        return 12

Add = 1
Sub = 2
Mult = 3
Div = 4
Mod = 5
Pow = 6
LShift = 7
RShift = 8
BitOr = 9
BitXor = 10
BitAnd = 11
FloorDiv = 12

operator_to_class = [
    _Add,
    _Sub,
    _Mult,
    _Div,
    _Mod,
    _Pow,
    _LShift,
    _RShift,
    _BitOr,
    _BitXor,
    _BitAnd,
    _FloorDiv,
]

class unaryop(AST):

    def to_simple_int(self, space):
        w_msg = space.wrap("not a valid unaryop")
        raise OperationError(space.w_TypeError, w_msg)

class _Invert(unaryop):

    def to_simple_int(self, space):
        return 1

class _Not(unaryop):

    def to_simple_int(self, space):
        return 2

class _UAdd(unaryop):

    def to_simple_int(self, space):
        return 3

class _USub(unaryop):

    def to_simple_int(self, space):
        return 4

Invert = 1
Not = 2
UAdd = 3
USub = 4

unaryop_to_class = [
    _Invert,
    _Not,
    _UAdd,
    _USub,
]

class cmpop(AST):

    def to_simple_int(self, space):
        w_msg = space.wrap("not a valid cmpop")
        raise OperationError(space.w_TypeError, w_msg)

class _Eq(cmpop):

    def to_simple_int(self, space):
        return 1

class _NotEq(cmpop):

    def to_simple_int(self, space):
        return 2

class _Lt(cmpop):

    def to_simple_int(self, space):
        return 3

class _LtE(cmpop):

    def to_simple_int(self, space):
        return 4

class _Gt(cmpop):

    def to_simple_int(self, space):
        return 5

class _GtE(cmpop):

    def to_simple_int(self, space):
        return 6

class _Is(cmpop):

    def to_simple_int(self, space):
        return 7

class _IsNot(cmpop):

    def to_simple_int(self, space):
        return 8

class _In(cmpop):

    def to_simple_int(self, space):
        return 9

class _NotIn(cmpop):

    def to_simple_int(self, space):
        return 10

Eq = 1
NotEq = 2
Lt = 3
LtE = 4
Gt = 5
GtE = 6
Is = 7
IsNot = 8
In = 9
NotIn = 10

cmpop_to_class = [
    _Eq,
    _NotEq,
    _Lt,
    _LtE,
    _Gt,
    _GtE,
    _Is,
    _IsNot,
    _In,
    _NotIn,
]

class comprehension(AST):

    __slots__ = ('target', 'iter', 'ifs', 'w_ifs')

    def __init__(self, target, iter, ifs):
        self.target = target
        self.iter = iter
        self.ifs = ifs
        self.w_ifs = None
        self.initialization_state = 7

    def walkabout(self, visitor):
        visitor.visit_comprehension(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 7:
            missing_field(space, self.initialization_state, ['target', 'iter', 'ifs'], 'comprehension')
        else:
            pass
        self.target.sync_app_attrs(space)
        self.iter.sync_app_attrs(space)
        w_list = self.w_ifs
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.ifs = [space.interp_w(expr, w_obj) for w_obj in list_w]
            else:
                self.ifs = None
        if self.ifs is not None:
            for node in self.ifs:
                node.sync_app_attrs(space)

class excepthandler(AST):

    __slots__ = ('type', 'name', 'body', 'w_body', 'lineno', 'col_offset')

    def __init__(self, type, name, body, lineno, col_offset):
        self.type = type
        self.name = name
        self.body = body
        self.w_body = None
        self.lineno = lineno
        self.col_offset = col_offset
        self.initialization_state = 31

    def walkabout(self, visitor):
        visitor.visit_excepthandler(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~3) ^ 28:
            missing_field(space, self.initialization_state, [None, None, 'body', 'lineno', 'col_offset'], 'excepthandler')
        else:
            if not self.initialization_state & 1:
                self.type = None
            if not self.initialization_state & 2:
                self.name = None
        if self.type:
            self.type.sync_app_attrs(space)
        if self.name:
            self.name.sync_app_attrs(space)
        w_list = self.w_body
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.body = [space.interp_w(stmt, w_obj) for w_obj in list_w]
            else:
                self.body = None
        if self.body is not None:
            for node in self.body:
                node.sync_app_attrs(space)

class arguments(AST):

    __slots__ = ('args', 'w_args', 'vararg', 'kwarg', 'defaults', 'w_defaults')

    def __init__(self, args, vararg, kwarg, defaults):
        self.args = args
        self.w_args = None
        self.vararg = vararg
        self.kwarg = kwarg
        self.defaults = defaults
        self.w_defaults = None
        self.initialization_state = 15

    def walkabout(self, visitor):
        visitor.visit_arguments(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~6) ^ 9:
            missing_field(space, self.initialization_state, ['args', None, None, 'defaults'], 'arguments')
        else:
            if not self.initialization_state & 2:
                self.vararg = None
            if not self.initialization_state & 4:
                self.kwarg = None
        w_list = self.w_args
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.args = [space.interp_w(expr, w_obj) for w_obj in list_w]
            else:
                self.args = None
        if self.args is not None:
            for node in self.args:
                node.sync_app_attrs(space)
        w_list = self.w_defaults
        if w_list is not None:
            list_w = space.listview(w_list)
            if list_w:
                self.defaults = [space.interp_w(expr, w_obj) for w_obj in list_w]
            else:
                self.defaults = None
        if self.defaults is not None:
            for node in self.defaults:
                node.sync_app_attrs(space)

class keyword(AST):

    __slots__ = ('arg', 'value')

    def __init__(self, arg, value):
        self.arg = arg
        self.value = value
        self.initialization_state = 3

    def walkabout(self, visitor):
        visitor.visit_keyword(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~0) ^ 3:
            missing_field(space, self.initialization_state, ['arg', 'value'], 'keyword')
        else:
            pass
        self.value.sync_app_attrs(space)

class alias(AST):

    __slots__ = ('name', 'asname')

    def __init__(self, name, asname):
        self.name = name
        self.asname = asname
        self.initialization_state = 3

    def walkabout(self, visitor):
        visitor.visit_alias(self)

    def sync_app_attrs(self, space):
        if (self.initialization_state & ~2) ^ 1:
            missing_field(space, self.initialization_state, ['name', None], 'alias')
        else:
            if not self.initialization_state & 2:
                self.asname = None

class ASTVisitor(object):

    def visit_sequence(self, seq):
        for node in seq:
            node.walkabout(self)

    def default_visitor(self, node):
        raise NodeVisitorNotImplemented

    def _mutate_sequence(self, seq):
        for i in range(len(seq)):
            seq[i] = seq[i].mutate_over(self)

    def visit_Module(self, node):
        return self.default_visitor(node)
    def visit_Interactive(self, node):
        return self.default_visitor(node)
    def visit_Expression(self, node):
        return self.default_visitor(node)
    def visit_Suite(self, node):
        return self.default_visitor(node)
    def visit_FunctionDef(self, node):
        return self.default_visitor(node)
    def visit_ClassDef(self, node):
        return self.default_visitor(node)
    def visit_Return(self, node):
        return self.default_visitor(node)
    def visit_Delete(self, node):
        return self.default_visitor(node)
    def visit_Assign(self, node):
        return self.default_visitor(node)
    def visit_AugAssign(self, node):
        return self.default_visitor(node)
    def visit_Print(self, node):
        return self.default_visitor(node)
    def visit_For(self, node):
        return self.default_visitor(node)
    def visit_While(self, node):
        return self.default_visitor(node)
    def visit_If(self, node):
        return self.default_visitor(node)
    def visit_With(self, node):
        return self.default_visitor(node)
    def visit_Raise(self, node):
        return self.default_visitor(node)
    def visit_TryExcept(self, node):
        return self.default_visitor(node)
    def visit_TryFinally(self, node):
        return self.default_visitor(node)
    def visit_Assert(self, node):
        return self.default_visitor(node)
    def visit_Import(self, node):
        return self.default_visitor(node)
    def visit_ImportFrom(self, node):
        return self.default_visitor(node)
    def visit_Exec(self, node):
        return self.default_visitor(node)
    def visit_Global(self, node):
        return self.default_visitor(node)
    def visit_Expr(self, node):
        return self.default_visitor(node)
    def visit_Pass(self, node):
        return self.default_visitor(node)
    def visit_Break(self, node):
        return self.default_visitor(node)
    def visit_Continue(self, node):
        return self.default_visitor(node)
    def visit_BoolOp(self, node):
        return self.default_visitor(node)
    def visit_BinOp(self, node):
        return self.default_visitor(node)
    def visit_UnaryOp(self, node):
        return self.default_visitor(node)
    def visit_Lambda(self, node):
        return self.default_visitor(node)
    def visit_IfExp(self, node):
        return self.default_visitor(node)
    def visit_Dict(self, node):
        return self.default_visitor(node)
    def visit_ListComp(self, node):
        return self.default_visitor(node)
    def visit_GeneratorExp(self, node):
        return self.default_visitor(node)
    def visit_Yield(self, node):
        return self.default_visitor(node)
    def visit_Compare(self, node):
        return self.default_visitor(node)
    def visit_Call(self, node):
        return self.default_visitor(node)
    def visit_Repr(self, node):
        return self.default_visitor(node)
    def visit_Num(self, node):
        return self.default_visitor(node)
    def visit_Str(self, node):
        return self.default_visitor(node)
    def visit_Attribute(self, node):
        return self.default_visitor(node)
    def visit_Subscript(self, node):
        return self.default_visitor(node)
    def visit_Name(self, node):
        return self.default_visitor(node)
    def visit_List(self, node):
        return self.default_visitor(node)
    def visit_Tuple(self, node):
        return self.default_visitor(node)
    def visit_Const(self, node):
        return self.default_visitor(node)
    def visit_Ellipsis(self, node):
        return self.default_visitor(node)
    def visit_Slice(self, node):
        return self.default_visitor(node)
    def visit_ExtSlice(self, node):
        return self.default_visitor(node)
    def visit_Index(self, node):
        return self.default_visitor(node)
    def visit_comprehension(self, node):
        return self.default_visitor(node)
    def visit_excepthandler(self, node):
        return self.default_visitor(node)
    def visit_arguments(self, node):
        return self.default_visitor(node)
    def visit_keyword(self, node):
        return self.default_visitor(node)
    def visit_alias(self, node):
        return self.default_visitor(node)

class GenericASTVisitor(ASTVisitor):

    def visit_Module(self, node):
        if node.body:
            self.visit_sequence(node.body)

    def visit_Interactive(self, node):
        if node.body:
            self.visit_sequence(node.body)

    def visit_Expression(self, node):
        node.body.walkabout(self)

    def visit_Suite(self, node):
        if node.body:
            self.visit_sequence(node.body)

    def visit_FunctionDef(self, node):
        node.args.walkabout(self)
        if node.body:
            self.visit_sequence(node.body)
        if node.decorators:
            self.visit_sequence(node.decorators)

    def visit_ClassDef(self, node):
        if node.bases:
            self.visit_sequence(node.bases)
        if node.body:
            self.visit_sequence(node.body)

    def visit_Return(self, node):
        if node.value:
            node.value.walkabout(self)

    def visit_Delete(self, node):
        if node.targets:
            self.visit_sequence(node.targets)

    def visit_Assign(self, node):
        if node.targets:
            self.visit_sequence(node.targets)
        node.value.walkabout(self)

    def visit_AugAssign(self, node):
        node.target.walkabout(self)
        node.value.walkabout(self)

    def visit_Print(self, node):
        if node.dest:
            node.dest.walkabout(self)
        if node.values:
            self.visit_sequence(node.values)

    def visit_For(self, node):
        node.target.walkabout(self)
        node.iter.walkabout(self)
        if node.body:
            self.visit_sequence(node.body)
        if node.orelse:
            self.visit_sequence(node.orelse)

    def visit_While(self, node):
        node.test.walkabout(self)
        if node.body:
            self.visit_sequence(node.body)
        if node.orelse:
            self.visit_sequence(node.orelse)

    def visit_If(self, node):
        node.test.walkabout(self)
        if node.body:
            self.visit_sequence(node.body)
        if node.orelse:
            self.visit_sequence(node.orelse)

    def visit_With(self, node):
        node.context_expr.walkabout(self)
        if node.optional_vars:
            node.optional_vars.walkabout(self)
        if node.body:
            self.visit_sequence(node.body)

    def visit_Raise(self, node):
        if node.type:
            node.type.walkabout(self)
        if node.inst:
            node.inst.walkabout(self)
        if node.tback:
            node.tback.walkabout(self)

    def visit_TryExcept(self, node):
        if node.body:
            self.visit_sequence(node.body)
        if node.handlers:
            self.visit_sequence(node.handlers)
        if node.orelse:
            self.visit_sequence(node.orelse)

    def visit_TryFinally(self, node):
        if node.body:
            self.visit_sequence(node.body)
        if node.finalbody:
            self.visit_sequence(node.finalbody)

    def visit_Assert(self, node):
        node.test.walkabout(self)
        if node.msg:
            node.msg.walkabout(self)

    def visit_Import(self, node):
        if node.names:
            self.visit_sequence(node.names)

    def visit_ImportFrom(self, node):
        if node.names:
            self.visit_sequence(node.names)

    def visit_Exec(self, node):
        node.body.walkabout(self)
        if node.globals:
            node.globals.walkabout(self)
        if node.locals:
            node.locals.walkabout(self)

    def visit_Global(self, node):
        pass

    def visit_Expr(self, node):
        node.value.walkabout(self)

    def visit_Pass(self, node):
        pass

    def visit_Break(self, node):
        pass

    def visit_Continue(self, node):
        pass

    def visit_BoolOp(self, node):
        if node.values:
            self.visit_sequence(node.values)

    def visit_BinOp(self, node):
        node.left.walkabout(self)
        node.right.walkabout(self)

    def visit_UnaryOp(self, node):
        node.operand.walkabout(self)

    def visit_Lambda(self, node):
        node.args.walkabout(self)
        node.body.walkabout(self)

    def visit_IfExp(self, node):
        node.test.walkabout(self)
        node.body.walkabout(self)
        node.orelse.walkabout(self)

    def visit_Dict(self, node):
        if node.keys:
            self.visit_sequence(node.keys)
        if node.values:
            self.visit_sequence(node.values)

    def visit_ListComp(self, node):
        node.elt.walkabout(self)
        if node.generators:
            self.visit_sequence(node.generators)

    def visit_GeneratorExp(self, node):
        node.elt.walkabout(self)
        if node.generators:
            self.visit_sequence(node.generators)

    def visit_Yield(self, node):
        if node.value:
            node.value.walkabout(self)

    def visit_Compare(self, node):
        node.left.walkabout(self)
        if node.comparators:
            self.visit_sequence(node.comparators)

    def visit_Call(self, node):
        node.func.walkabout(self)
        if node.args:
            self.visit_sequence(node.args)
        if node.keywords:
            self.visit_sequence(node.keywords)
        if node.starargs:
            node.starargs.walkabout(self)
        if node.kwargs:
            node.kwargs.walkabout(self)

    def visit_Repr(self, node):
        node.value.walkabout(self)

    def visit_Num(self, node):
        pass

    def visit_Str(self, node):
        pass

    def visit_Attribute(self, node):
        node.value.walkabout(self)

    def visit_Subscript(self, node):
        node.value.walkabout(self)
        node.slice.walkabout(self)

    def visit_Name(self, node):
        pass

    def visit_List(self, node):
        if node.elts:
            self.visit_sequence(node.elts)

    def visit_Tuple(self, node):
        if node.elts:
            self.visit_sequence(node.elts)

    def visit_Const(self, node):
        pass

    def visit_Ellipsis(self, node):
        pass

    def visit_Slice(self, node):
        if node.lower:
            node.lower.walkabout(self)
        if node.upper:
            node.upper.walkabout(self)
        if node.step:
            node.step.walkabout(self)

    def visit_ExtSlice(self, node):
        if node.dims:
            self.visit_sequence(node.dims)

    def visit_Index(self, node):
        node.value.walkabout(self)

    def visit_comprehension(self, node):
        node.target.walkabout(self)
        node.iter.walkabout(self)
        if node.ifs:
            self.visit_sequence(node.ifs)

    def visit_excepthandler(self, node):
        if node.type:
            node.type.walkabout(self)
        if node.name:
            node.name.walkabout(self)
        if node.body:
            self.visit_sequence(node.body)

    def visit_arguments(self, node):
        if node.args:
            self.visit_sequence(node.args)
        if node.defaults:
            self.visit_sequence(node.defaults)

    def visit_keyword(self, node):
        node.value.walkabout(self)

    def visit_alias(self, node):
        pass


mod.typedef = typedef.TypeDef("mod",
    AST.typedef,
    _attributes=_FieldsWrapper([]),
)
mod.typedef.acceptable_as_base_class = False

def Module_get_body(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'body' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_body is None:
        if w_self.body is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.body]
            w_list = space.newlist(list_w)
        w_self.w_body = w_list
    return w_self.w_body

def Module_set_body(space, w_self, w_new_value):
    w_self.w_body = w_new_value
    w_self.initialization_state |= 1

_Module_field_unroller = unrolling_iterable(['body'])
def Module_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Module, w_self)
    w_self.w_body = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 1:
            w_err = space.wrap("Module constructor takes 0 or 1 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Module_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Module_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Module.typedef = typedef.TypeDef("Module",
    mod.typedef,
    _fields=_FieldsWrapper(['body']),
    body=typedef.GetSetProperty(Module_get_body, Module_set_body, cls=Module),
    __new__=interp2app(get_AST_new(Module)),
    __init__=interp2app(Module_init),
)
Module.typedef.acceptable_as_base_class = False

def Interactive_get_body(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'body' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_body is None:
        if w_self.body is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.body]
            w_list = space.newlist(list_w)
        w_self.w_body = w_list
    return w_self.w_body

def Interactive_set_body(space, w_self, w_new_value):
    w_self.w_body = w_new_value
    w_self.initialization_state |= 1

_Interactive_field_unroller = unrolling_iterable(['body'])
def Interactive_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Interactive, w_self)
    w_self.w_body = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 1:
            w_err = space.wrap("Interactive constructor takes 0 or 1 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Interactive_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Interactive_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Interactive.typedef = typedef.TypeDef("Interactive",
    mod.typedef,
    _fields=_FieldsWrapper(['body']),
    body=typedef.GetSetProperty(Interactive_get_body, Interactive_set_body, cls=Interactive),
    __new__=interp2app(get_AST_new(Interactive)),
    __init__=interp2app(Interactive_init),
)
Interactive.typedef.acceptable_as_base_class = False

def Expression_get_body(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'body' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.body)

def Expression_set_body(space, w_self, w_new_value):
    w_self.body = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 1

_Expression_field_unroller = unrolling_iterable(['body'])
def Expression_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Expression, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 1:
            w_err = space.wrap("Expression constructor takes 0 or 1 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Expression_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Expression_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Expression.typedef = typedef.TypeDef("Expression",
    mod.typedef,
    _fields=_FieldsWrapper(['body']),
    body=typedef.GetSetProperty(Expression_get_body, Expression_set_body, cls=Expression),
    __new__=interp2app(get_AST_new(Expression)),
    __init__=interp2app(Expression_init),
)
Expression.typedef.acceptable_as_base_class = False

def Suite_get_body(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'body' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_body is None:
        if w_self.body is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.body]
            w_list = space.newlist(list_w)
        w_self.w_body = w_list
    return w_self.w_body

def Suite_set_body(space, w_self, w_new_value):
    w_self.w_body = w_new_value
    w_self.initialization_state |= 1

_Suite_field_unroller = unrolling_iterable(['body'])
def Suite_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Suite, w_self)
    w_self.w_body = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 1:
            w_err = space.wrap("Suite constructor takes 0 or 1 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Suite_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Suite_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Suite.typedef = typedef.TypeDef("Suite",
    mod.typedef,
    _fields=_FieldsWrapper(['body']),
    body=typedef.GetSetProperty(Suite_get_body, Suite_set_body, cls=Suite),
    __new__=interp2app(get_AST_new(Suite)),
    __init__=interp2app(Suite_init),
)
Suite.typedef.acceptable_as_base_class = False

def stmt_get_lineno(space, w_self):
    if not w_self.initialization_state & w_self._lineno_mask:
        w_err = space.wrap("attribute 'lineno' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.lineno)

def stmt_set_lineno(space, w_self, w_new_value):
    w_self.lineno = space.int_w(w_new_value)
    w_self.initialization_state |= w_self._lineno_mask

def stmt_get_col_offset(space, w_self):
    if not w_self.initialization_state & w_self._col_offset_mask:
        w_err = space.wrap("attribute 'col_offset' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.col_offset)

def stmt_set_col_offset(space, w_self, w_new_value):
    w_self.col_offset = space.int_w(w_new_value)
    w_self.initialization_state |= w_self._col_offset_mask

stmt.typedef = typedef.TypeDef("stmt",
    AST.typedef,
    _attributes=_FieldsWrapper(['lineno', 'col_offset']),
    lineno=typedef.GetSetProperty(stmt_get_lineno, stmt_set_lineno, cls=stmt),
    col_offset=typedef.GetSetProperty(stmt_get_col_offset, stmt_set_col_offset, cls=stmt),
)
stmt.typedef.acceptable_as_base_class = False

def FunctionDef_get_name(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'name' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.name)

def FunctionDef_set_name(space, w_self, w_new_value):
    w_self.name = space.str_w(w_new_value)
    w_self.initialization_state |= 1

def FunctionDef_get_args(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'args' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.args)

def FunctionDef_set_args(space, w_self, w_new_value):
    w_self.args = space.interp_w(arguments, w_new_value, False)
    w_self.initialization_state |= 2

def FunctionDef_get_body(space, w_self):
    if not w_self.initialization_state & 4:
        w_err = space.wrap("attribute 'body' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_body is None:
        if w_self.body is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.body]
            w_list = space.newlist(list_w)
        w_self.w_body = w_list
    return w_self.w_body

def FunctionDef_set_body(space, w_self, w_new_value):
    w_self.w_body = w_new_value
    w_self.initialization_state |= 4

def FunctionDef_get_decorators(space, w_self):
    if not w_self.initialization_state & 8:
        w_err = space.wrap("attribute 'decorators' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_decorators is None:
        if w_self.decorators is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.decorators]
            w_list = space.newlist(list_w)
        w_self.w_decorators = w_list
    return w_self.w_decorators

def FunctionDef_set_decorators(space, w_self, w_new_value):
    w_self.w_decorators = w_new_value
    w_self.initialization_state |= 8

_FunctionDef_field_unroller = unrolling_iterable(['name', 'args', 'body', 'decorators', 'lineno', 'col_offset'])
def FunctionDef_init(space, w_self, args):
    w_self = space.descr_self_interp_w(FunctionDef, w_self)
    w_self.w_body = None
    w_self.w_decorators = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 6:
            w_err = space.wrap("FunctionDef constructor takes 0 or 6 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _FunctionDef_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
FunctionDef_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

FunctionDef.typedef = typedef.TypeDef("FunctionDef",
    stmt.typedef,
    _fields=_FieldsWrapper(['name', 'args', 'body', 'decorators']),
    name=typedef.GetSetProperty(FunctionDef_get_name, FunctionDef_set_name, cls=FunctionDef),
    args=typedef.GetSetProperty(FunctionDef_get_args, FunctionDef_set_args, cls=FunctionDef),
    body=typedef.GetSetProperty(FunctionDef_get_body, FunctionDef_set_body, cls=FunctionDef),
    decorators=typedef.GetSetProperty(FunctionDef_get_decorators, FunctionDef_set_decorators, cls=FunctionDef),
    __new__=interp2app(get_AST_new(FunctionDef)),
    __init__=interp2app(FunctionDef_init),
)
FunctionDef.typedef.acceptable_as_base_class = False

def ClassDef_get_name(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'name' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.name)

def ClassDef_set_name(space, w_self, w_new_value):
    w_self.name = space.str_w(w_new_value)
    w_self.initialization_state |= 1

def ClassDef_get_bases(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'bases' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_bases is None:
        if w_self.bases is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.bases]
            w_list = space.newlist(list_w)
        w_self.w_bases = w_list
    return w_self.w_bases

def ClassDef_set_bases(space, w_self, w_new_value):
    w_self.w_bases = w_new_value
    w_self.initialization_state |= 2

def ClassDef_get_body(space, w_self):
    if not w_self.initialization_state & 4:
        w_err = space.wrap("attribute 'body' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_body is None:
        if w_self.body is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.body]
            w_list = space.newlist(list_w)
        w_self.w_body = w_list
    return w_self.w_body

def ClassDef_set_body(space, w_self, w_new_value):
    w_self.w_body = w_new_value
    w_self.initialization_state |= 4

_ClassDef_field_unroller = unrolling_iterable(['name', 'bases', 'body', 'lineno', 'col_offset'])
def ClassDef_init(space, w_self, args):
    w_self = space.descr_self_interp_w(ClassDef, w_self)
    w_self.w_bases = None
    w_self.w_body = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 5:
            w_err = space.wrap("ClassDef constructor takes 0 or 5 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _ClassDef_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
ClassDef_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

ClassDef.typedef = typedef.TypeDef("ClassDef",
    stmt.typedef,
    _fields=_FieldsWrapper(['name', 'bases', 'body']),
    name=typedef.GetSetProperty(ClassDef_get_name, ClassDef_set_name, cls=ClassDef),
    bases=typedef.GetSetProperty(ClassDef_get_bases, ClassDef_set_bases, cls=ClassDef),
    body=typedef.GetSetProperty(ClassDef_get_body, ClassDef_set_body, cls=ClassDef),
    __new__=interp2app(get_AST_new(ClassDef)),
    __init__=interp2app(ClassDef_init),
)
ClassDef.typedef.acceptable_as_base_class = False

def Return_get_value(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'value' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.value)

def Return_set_value(space, w_self, w_new_value):
    w_self.value = space.interp_w(expr, w_new_value, True)
    w_self.initialization_state |= 1

_Return_field_unroller = unrolling_iterable(['value', 'lineno', 'col_offset'])
def Return_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Return, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("Return constructor takes 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Return_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Return_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Return.typedef = typedef.TypeDef("Return",
    stmt.typedef,
    _fields=_FieldsWrapper(['value']),
    value=typedef.GetSetProperty(Return_get_value, Return_set_value, cls=Return),
    __new__=interp2app(get_AST_new(Return)),
    __init__=interp2app(Return_init),
)
Return.typedef.acceptable_as_base_class = False

def Delete_get_targets(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'targets' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_targets is None:
        if w_self.targets is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.targets]
            w_list = space.newlist(list_w)
        w_self.w_targets = w_list
    return w_self.w_targets

def Delete_set_targets(space, w_self, w_new_value):
    w_self.w_targets = w_new_value
    w_self.initialization_state |= 1

_Delete_field_unroller = unrolling_iterable(['targets', 'lineno', 'col_offset'])
def Delete_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Delete, w_self)
    w_self.w_targets = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("Delete constructor takes 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Delete_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Delete_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Delete.typedef = typedef.TypeDef("Delete",
    stmt.typedef,
    _fields=_FieldsWrapper(['targets']),
    targets=typedef.GetSetProperty(Delete_get_targets, Delete_set_targets, cls=Delete),
    __new__=interp2app(get_AST_new(Delete)),
    __init__=interp2app(Delete_init),
)
Delete.typedef.acceptable_as_base_class = False

def Assign_get_targets(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'targets' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_targets is None:
        if w_self.targets is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.targets]
            w_list = space.newlist(list_w)
        w_self.w_targets = w_list
    return w_self.w_targets

def Assign_set_targets(space, w_self, w_new_value):
    w_self.w_targets = w_new_value
    w_self.initialization_state |= 1

def Assign_get_value(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'value' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.value)

def Assign_set_value(space, w_self, w_new_value):
    w_self.value = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 2

_Assign_field_unroller = unrolling_iterable(['targets', 'value', 'lineno', 'col_offset'])
def Assign_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Assign, w_self)
    w_self.w_targets = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 4:
            w_err = space.wrap("Assign constructor takes 0 or 4 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Assign_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Assign_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Assign.typedef = typedef.TypeDef("Assign",
    stmt.typedef,
    _fields=_FieldsWrapper(['targets', 'value']),
    targets=typedef.GetSetProperty(Assign_get_targets, Assign_set_targets, cls=Assign),
    value=typedef.GetSetProperty(Assign_get_value, Assign_set_value, cls=Assign),
    __new__=interp2app(get_AST_new(Assign)),
    __init__=interp2app(Assign_init),
)
Assign.typedef.acceptable_as_base_class = False

def AugAssign_get_target(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'target' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.target)

def AugAssign_set_target(space, w_self, w_new_value):
    w_self.target = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 1

def AugAssign_get_op(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'op' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return operator_to_class[w_self.op - 1]()

def AugAssign_set_op(space, w_self, w_new_value):
    obj = space.interp_w(operator, w_new_value)
    w_self.op = obj.to_simple_int(space)
    w_self.initialization_state |= 2

def AugAssign_get_value(space, w_self):
    if not w_self.initialization_state & 4:
        w_err = space.wrap("attribute 'value' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.value)

def AugAssign_set_value(space, w_self, w_new_value):
    w_self.value = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 4

_AugAssign_field_unroller = unrolling_iterable(['target', 'op', 'value', 'lineno', 'col_offset'])
def AugAssign_init(space, w_self, args):
    w_self = space.descr_self_interp_w(AugAssign, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 5:
            w_err = space.wrap("AugAssign constructor takes 0 or 5 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _AugAssign_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
AugAssign_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

AugAssign.typedef = typedef.TypeDef("AugAssign",
    stmt.typedef,
    _fields=_FieldsWrapper(['target', 'op', 'value']),
    target=typedef.GetSetProperty(AugAssign_get_target, AugAssign_set_target, cls=AugAssign),
    op=typedef.GetSetProperty(AugAssign_get_op, AugAssign_set_op, cls=AugAssign),
    value=typedef.GetSetProperty(AugAssign_get_value, AugAssign_set_value, cls=AugAssign),
    __new__=interp2app(get_AST_new(AugAssign)),
    __init__=interp2app(AugAssign_init),
)
AugAssign.typedef.acceptable_as_base_class = False

def Print_get_dest(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'dest' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.dest)

def Print_set_dest(space, w_self, w_new_value):
    w_self.dest = space.interp_w(expr, w_new_value, True)
    w_self.initialization_state |= 1

def Print_get_values(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'values' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_values is None:
        if w_self.values is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.values]
            w_list = space.newlist(list_w)
        w_self.w_values = w_list
    return w_self.w_values

def Print_set_values(space, w_self, w_new_value):
    w_self.w_values = w_new_value
    w_self.initialization_state |= 2

def Print_get_nl(space, w_self):
    if not w_self.initialization_state & 4:
        w_err = space.wrap("attribute 'nl' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.nl)

def Print_set_nl(space, w_self, w_new_value):
    w_self.nl = space.bool_w(w_new_value)
    w_self.initialization_state |= 4

_Print_field_unroller = unrolling_iterable(['dest', 'values', 'nl', 'lineno', 'col_offset'])
def Print_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Print, w_self)
    w_self.w_values = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 5:
            w_err = space.wrap("Print constructor takes 0 or 5 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Print_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Print_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Print.typedef = typedef.TypeDef("Print",
    stmt.typedef,
    _fields=_FieldsWrapper(['dest', 'values', 'nl']),
    dest=typedef.GetSetProperty(Print_get_dest, Print_set_dest, cls=Print),
    values=typedef.GetSetProperty(Print_get_values, Print_set_values, cls=Print),
    nl=typedef.GetSetProperty(Print_get_nl, Print_set_nl, cls=Print),
    __new__=interp2app(get_AST_new(Print)),
    __init__=interp2app(Print_init),
)
Print.typedef.acceptable_as_base_class = False

def For_get_target(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'target' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.target)

def For_set_target(space, w_self, w_new_value):
    w_self.target = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 1

def For_get_iter(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'iter' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.iter)

def For_set_iter(space, w_self, w_new_value):
    w_self.iter = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 2

def For_get_body(space, w_self):
    if not w_self.initialization_state & 4:
        w_err = space.wrap("attribute 'body' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_body is None:
        if w_self.body is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.body]
            w_list = space.newlist(list_w)
        w_self.w_body = w_list
    return w_self.w_body

def For_set_body(space, w_self, w_new_value):
    w_self.w_body = w_new_value
    w_self.initialization_state |= 4

def For_get_orelse(space, w_self):
    if not w_self.initialization_state & 8:
        w_err = space.wrap("attribute 'orelse' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_orelse is None:
        if w_self.orelse is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.orelse]
            w_list = space.newlist(list_w)
        w_self.w_orelse = w_list
    return w_self.w_orelse

def For_set_orelse(space, w_self, w_new_value):
    w_self.w_orelse = w_new_value
    w_self.initialization_state |= 8

_For_field_unroller = unrolling_iterable(['target', 'iter', 'body', 'orelse', 'lineno', 'col_offset'])
def For_init(space, w_self, args):
    w_self = space.descr_self_interp_w(For, w_self)
    w_self.w_body = None
    w_self.w_orelse = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 6:
            w_err = space.wrap("For constructor takes 0 or 6 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _For_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
For_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

For.typedef = typedef.TypeDef("For",
    stmt.typedef,
    _fields=_FieldsWrapper(['target', 'iter', 'body', 'orelse']),
    target=typedef.GetSetProperty(For_get_target, For_set_target, cls=For),
    iter=typedef.GetSetProperty(For_get_iter, For_set_iter, cls=For),
    body=typedef.GetSetProperty(For_get_body, For_set_body, cls=For),
    orelse=typedef.GetSetProperty(For_get_orelse, For_set_orelse, cls=For),
    __new__=interp2app(get_AST_new(For)),
    __init__=interp2app(For_init),
)
For.typedef.acceptable_as_base_class = False

def While_get_test(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'test' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.test)

def While_set_test(space, w_self, w_new_value):
    w_self.test = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 1

def While_get_body(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'body' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_body is None:
        if w_self.body is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.body]
            w_list = space.newlist(list_w)
        w_self.w_body = w_list
    return w_self.w_body

def While_set_body(space, w_self, w_new_value):
    w_self.w_body = w_new_value
    w_self.initialization_state |= 2

def While_get_orelse(space, w_self):
    if not w_self.initialization_state & 4:
        w_err = space.wrap("attribute 'orelse' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_orelse is None:
        if w_self.orelse is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.orelse]
            w_list = space.newlist(list_w)
        w_self.w_orelse = w_list
    return w_self.w_orelse

def While_set_orelse(space, w_self, w_new_value):
    w_self.w_orelse = w_new_value
    w_self.initialization_state |= 4

_While_field_unroller = unrolling_iterable(['test', 'body', 'orelse', 'lineno', 'col_offset'])
def While_init(space, w_self, args):
    w_self = space.descr_self_interp_w(While, w_self)
    w_self.w_body = None
    w_self.w_orelse = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 5:
            w_err = space.wrap("While constructor takes 0 or 5 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _While_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
While_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

While.typedef = typedef.TypeDef("While",
    stmt.typedef,
    _fields=_FieldsWrapper(['test', 'body', 'orelse']),
    test=typedef.GetSetProperty(While_get_test, While_set_test, cls=While),
    body=typedef.GetSetProperty(While_get_body, While_set_body, cls=While),
    orelse=typedef.GetSetProperty(While_get_orelse, While_set_orelse, cls=While),
    __new__=interp2app(get_AST_new(While)),
    __init__=interp2app(While_init),
)
While.typedef.acceptable_as_base_class = False

def If_get_test(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'test' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.test)

def If_set_test(space, w_self, w_new_value):
    w_self.test = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 1

def If_get_body(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'body' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_body is None:
        if w_self.body is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.body]
            w_list = space.newlist(list_w)
        w_self.w_body = w_list
    return w_self.w_body

def If_set_body(space, w_self, w_new_value):
    w_self.w_body = w_new_value
    w_self.initialization_state |= 2

def If_get_orelse(space, w_self):
    if not w_self.initialization_state & 4:
        w_err = space.wrap("attribute 'orelse' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_orelse is None:
        if w_self.orelse is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.orelse]
            w_list = space.newlist(list_w)
        w_self.w_orelse = w_list
    return w_self.w_orelse

def If_set_orelse(space, w_self, w_new_value):
    w_self.w_orelse = w_new_value
    w_self.initialization_state |= 4

_If_field_unroller = unrolling_iterable(['test', 'body', 'orelse', 'lineno', 'col_offset'])
def If_init(space, w_self, args):
    w_self = space.descr_self_interp_w(If, w_self)
    w_self.w_body = None
    w_self.w_orelse = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 5:
            w_err = space.wrap("If constructor takes 0 or 5 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _If_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
If_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

If.typedef = typedef.TypeDef("If",
    stmt.typedef,
    _fields=_FieldsWrapper(['test', 'body', 'orelse']),
    test=typedef.GetSetProperty(If_get_test, If_set_test, cls=If),
    body=typedef.GetSetProperty(If_get_body, If_set_body, cls=If),
    orelse=typedef.GetSetProperty(If_get_orelse, If_set_orelse, cls=If),
    __new__=interp2app(get_AST_new(If)),
    __init__=interp2app(If_init),
)
If.typedef.acceptable_as_base_class = False

def With_get_context_expr(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'context_expr' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.context_expr)

def With_set_context_expr(space, w_self, w_new_value):
    w_self.context_expr = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 1

def With_get_optional_vars(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'optional_vars' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.optional_vars)

def With_set_optional_vars(space, w_self, w_new_value):
    w_self.optional_vars = space.interp_w(expr, w_new_value, True)
    w_self.initialization_state |= 2

def With_get_body(space, w_self):
    if not w_self.initialization_state & 4:
        w_err = space.wrap("attribute 'body' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_body is None:
        if w_self.body is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.body]
            w_list = space.newlist(list_w)
        w_self.w_body = w_list
    return w_self.w_body

def With_set_body(space, w_self, w_new_value):
    w_self.w_body = w_new_value
    w_self.initialization_state |= 4

_With_field_unroller = unrolling_iterable(['context_expr', 'optional_vars', 'body', 'lineno', 'col_offset'])
def With_init(space, w_self, args):
    w_self = space.descr_self_interp_w(With, w_self)
    w_self.w_body = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 5:
            w_err = space.wrap("With constructor takes 0 or 5 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _With_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
With_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

With.typedef = typedef.TypeDef("With",
    stmt.typedef,
    _fields=_FieldsWrapper(['context_expr', 'optional_vars', 'body']),
    context_expr=typedef.GetSetProperty(With_get_context_expr, With_set_context_expr, cls=With),
    optional_vars=typedef.GetSetProperty(With_get_optional_vars, With_set_optional_vars, cls=With),
    body=typedef.GetSetProperty(With_get_body, With_set_body, cls=With),
    __new__=interp2app(get_AST_new(With)),
    __init__=interp2app(With_init),
)
With.typedef.acceptable_as_base_class = False

def Raise_get_type(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'type' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.type)

def Raise_set_type(space, w_self, w_new_value):
    w_self.type = space.interp_w(expr, w_new_value, True)
    w_self.initialization_state |= 1

def Raise_get_inst(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'inst' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.inst)

def Raise_set_inst(space, w_self, w_new_value):
    w_self.inst = space.interp_w(expr, w_new_value, True)
    w_self.initialization_state |= 2

def Raise_get_tback(space, w_self):
    if not w_self.initialization_state & 4:
        w_err = space.wrap("attribute 'tback' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.tback)

def Raise_set_tback(space, w_self, w_new_value):
    w_self.tback = space.interp_w(expr, w_new_value, True)
    w_self.initialization_state |= 4

_Raise_field_unroller = unrolling_iterable(['type', 'inst', 'tback', 'lineno', 'col_offset'])
def Raise_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Raise, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 5:
            w_err = space.wrap("Raise constructor takes 0 or 5 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Raise_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Raise_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Raise.typedef = typedef.TypeDef("Raise",
    stmt.typedef,
    _fields=_FieldsWrapper(['type', 'inst', 'tback']),
    type=typedef.GetSetProperty(Raise_get_type, Raise_set_type, cls=Raise),
    inst=typedef.GetSetProperty(Raise_get_inst, Raise_set_inst, cls=Raise),
    tback=typedef.GetSetProperty(Raise_get_tback, Raise_set_tback, cls=Raise),
    __new__=interp2app(get_AST_new(Raise)),
    __init__=interp2app(Raise_init),
)
Raise.typedef.acceptable_as_base_class = False

def TryExcept_get_body(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'body' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_body is None:
        if w_self.body is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.body]
            w_list = space.newlist(list_w)
        w_self.w_body = w_list
    return w_self.w_body

def TryExcept_set_body(space, w_self, w_new_value):
    w_self.w_body = w_new_value
    w_self.initialization_state |= 1

def TryExcept_get_handlers(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'handlers' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_handlers is None:
        if w_self.handlers is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.handlers]
            w_list = space.newlist(list_w)
        w_self.w_handlers = w_list
    return w_self.w_handlers

def TryExcept_set_handlers(space, w_self, w_new_value):
    w_self.w_handlers = w_new_value
    w_self.initialization_state |= 2

def TryExcept_get_orelse(space, w_self):
    if not w_self.initialization_state & 4:
        w_err = space.wrap("attribute 'orelse' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_orelse is None:
        if w_self.orelse is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.orelse]
            w_list = space.newlist(list_w)
        w_self.w_orelse = w_list
    return w_self.w_orelse

def TryExcept_set_orelse(space, w_self, w_new_value):
    w_self.w_orelse = w_new_value
    w_self.initialization_state |= 4

_TryExcept_field_unroller = unrolling_iterable(['body', 'handlers', 'orelse', 'lineno', 'col_offset'])
def TryExcept_init(space, w_self, args):
    w_self = space.descr_self_interp_w(TryExcept, w_self)
    w_self.w_body = None
    w_self.w_handlers = None
    w_self.w_orelse = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 5:
            w_err = space.wrap("TryExcept constructor takes 0 or 5 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _TryExcept_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
TryExcept_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

TryExcept.typedef = typedef.TypeDef("TryExcept",
    stmt.typedef,
    _fields=_FieldsWrapper(['body', 'handlers', 'orelse']),
    body=typedef.GetSetProperty(TryExcept_get_body, TryExcept_set_body, cls=TryExcept),
    handlers=typedef.GetSetProperty(TryExcept_get_handlers, TryExcept_set_handlers, cls=TryExcept),
    orelse=typedef.GetSetProperty(TryExcept_get_orelse, TryExcept_set_orelse, cls=TryExcept),
    __new__=interp2app(get_AST_new(TryExcept)),
    __init__=interp2app(TryExcept_init),
)
TryExcept.typedef.acceptable_as_base_class = False

def TryFinally_get_body(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'body' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_body is None:
        if w_self.body is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.body]
            w_list = space.newlist(list_w)
        w_self.w_body = w_list
    return w_self.w_body

def TryFinally_set_body(space, w_self, w_new_value):
    w_self.w_body = w_new_value
    w_self.initialization_state |= 1

def TryFinally_get_finalbody(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'finalbody' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_finalbody is None:
        if w_self.finalbody is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.finalbody]
            w_list = space.newlist(list_w)
        w_self.w_finalbody = w_list
    return w_self.w_finalbody

def TryFinally_set_finalbody(space, w_self, w_new_value):
    w_self.w_finalbody = w_new_value
    w_self.initialization_state |= 2

_TryFinally_field_unroller = unrolling_iterable(['body', 'finalbody', 'lineno', 'col_offset'])
def TryFinally_init(space, w_self, args):
    w_self = space.descr_self_interp_w(TryFinally, w_self)
    w_self.w_body = None
    w_self.w_finalbody = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 4:
            w_err = space.wrap("TryFinally constructor takes 0 or 4 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _TryFinally_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
TryFinally_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

TryFinally.typedef = typedef.TypeDef("TryFinally",
    stmt.typedef,
    _fields=_FieldsWrapper(['body', 'finalbody']),
    body=typedef.GetSetProperty(TryFinally_get_body, TryFinally_set_body, cls=TryFinally),
    finalbody=typedef.GetSetProperty(TryFinally_get_finalbody, TryFinally_set_finalbody, cls=TryFinally),
    __new__=interp2app(get_AST_new(TryFinally)),
    __init__=interp2app(TryFinally_init),
)
TryFinally.typedef.acceptable_as_base_class = False

def Assert_get_test(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'test' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.test)

def Assert_set_test(space, w_self, w_new_value):
    w_self.test = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 1

def Assert_get_msg(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'msg' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.msg)

def Assert_set_msg(space, w_self, w_new_value):
    w_self.msg = space.interp_w(expr, w_new_value, True)
    w_self.initialization_state |= 2

_Assert_field_unroller = unrolling_iterable(['test', 'msg', 'lineno', 'col_offset'])
def Assert_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Assert, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 4:
            w_err = space.wrap("Assert constructor takes 0 or 4 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Assert_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Assert_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Assert.typedef = typedef.TypeDef("Assert",
    stmt.typedef,
    _fields=_FieldsWrapper(['test', 'msg']),
    test=typedef.GetSetProperty(Assert_get_test, Assert_set_test, cls=Assert),
    msg=typedef.GetSetProperty(Assert_get_msg, Assert_set_msg, cls=Assert),
    __new__=interp2app(get_AST_new(Assert)),
    __init__=interp2app(Assert_init),
)
Assert.typedef.acceptable_as_base_class = False

def Import_get_names(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'names' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_names is None:
        if w_self.names is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.names]
            w_list = space.newlist(list_w)
        w_self.w_names = w_list
    return w_self.w_names

def Import_set_names(space, w_self, w_new_value):
    w_self.w_names = w_new_value
    w_self.initialization_state |= 1

_Import_field_unroller = unrolling_iterable(['names', 'lineno', 'col_offset'])
def Import_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Import, w_self)
    w_self.w_names = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("Import constructor takes 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Import_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Import_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Import.typedef = typedef.TypeDef("Import",
    stmt.typedef,
    _fields=_FieldsWrapper(['names']),
    names=typedef.GetSetProperty(Import_get_names, Import_set_names, cls=Import),
    __new__=interp2app(get_AST_new(Import)),
    __init__=interp2app(Import_init),
)
Import.typedef.acceptable_as_base_class = False

def ImportFrom_get_module(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'module' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.module)

def ImportFrom_set_module(space, w_self, w_new_value):
    if space.is_w(w_new_value, space.w_None):
        w_self.module = None
    else:
        w_self.module = space.str_w(w_new_value)
    w_self.initialization_state |= 1

def ImportFrom_get_names(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'names' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_names is None:
        if w_self.names is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.names]
            w_list = space.newlist(list_w)
        w_self.w_names = w_list
    return w_self.w_names

def ImportFrom_set_names(space, w_self, w_new_value):
    w_self.w_names = w_new_value
    w_self.initialization_state |= 2

def ImportFrom_get_level(space, w_self):
    if not w_self.initialization_state & 4:
        w_err = space.wrap("attribute 'level' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.level)

def ImportFrom_set_level(space, w_self, w_new_value):
    w_self.level = space.int_w(w_new_value)
    w_self.initialization_state |= 4

_ImportFrom_field_unroller = unrolling_iterable(['module', 'names', 'level', 'lineno', 'col_offset'])
def ImportFrom_init(space, w_self, args):
    w_self = space.descr_self_interp_w(ImportFrom, w_self)
    w_self.w_names = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 5:
            w_err = space.wrap("ImportFrom constructor takes 0 or 5 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _ImportFrom_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
ImportFrom_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

ImportFrom.typedef = typedef.TypeDef("ImportFrom",
    stmt.typedef,
    _fields=_FieldsWrapper(['module', 'names', 'level']),
    module=typedef.GetSetProperty(ImportFrom_get_module, ImportFrom_set_module, cls=ImportFrom),
    names=typedef.GetSetProperty(ImportFrom_get_names, ImportFrom_set_names, cls=ImportFrom),
    level=typedef.GetSetProperty(ImportFrom_get_level, ImportFrom_set_level, cls=ImportFrom),
    __new__=interp2app(get_AST_new(ImportFrom)),
    __init__=interp2app(ImportFrom_init),
)
ImportFrom.typedef.acceptable_as_base_class = False

def Exec_get_body(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'body' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.body)

def Exec_set_body(space, w_self, w_new_value):
    w_self.body = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 1

def Exec_get_globals(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'globals' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.globals)

def Exec_set_globals(space, w_self, w_new_value):
    w_self.globals = space.interp_w(expr, w_new_value, True)
    w_self.initialization_state |= 2

def Exec_get_locals(space, w_self):
    if not w_self.initialization_state & 4:
        w_err = space.wrap("attribute 'locals' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.locals)

def Exec_set_locals(space, w_self, w_new_value):
    w_self.locals = space.interp_w(expr, w_new_value, True)
    w_self.initialization_state |= 4

_Exec_field_unroller = unrolling_iterable(['body', 'globals', 'locals', 'lineno', 'col_offset'])
def Exec_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Exec, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 5:
            w_err = space.wrap("Exec constructor takes 0 or 5 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Exec_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Exec_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Exec.typedef = typedef.TypeDef("Exec",
    stmt.typedef,
    _fields=_FieldsWrapper(['body', 'globals', 'locals']),
    body=typedef.GetSetProperty(Exec_get_body, Exec_set_body, cls=Exec),
    globals=typedef.GetSetProperty(Exec_get_globals, Exec_set_globals, cls=Exec),
    locals=typedef.GetSetProperty(Exec_get_locals, Exec_set_locals, cls=Exec),
    __new__=interp2app(get_AST_new(Exec)),
    __init__=interp2app(Exec_init),
)
Exec.typedef.acceptable_as_base_class = False

def Global_get_names(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'names' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_names is None:
        if w_self.names is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.names]
            w_list = space.newlist(list_w)
        w_self.w_names = w_list
    return w_self.w_names

def Global_set_names(space, w_self, w_new_value):
    w_self.w_names = w_new_value
    w_self.initialization_state |= 1

_Global_field_unroller = unrolling_iterable(['names', 'lineno', 'col_offset'])
def Global_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Global, w_self)
    w_self.w_names = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("Global constructor takes 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Global_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Global_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Global.typedef = typedef.TypeDef("Global",
    stmt.typedef,
    _fields=_FieldsWrapper(['names']),
    names=typedef.GetSetProperty(Global_get_names, Global_set_names, cls=Global),
    __new__=interp2app(get_AST_new(Global)),
    __init__=interp2app(Global_init),
)
Global.typedef.acceptable_as_base_class = False

def Expr_get_value(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'value' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.value)

def Expr_set_value(space, w_self, w_new_value):
    w_self.value = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 1

_Expr_field_unroller = unrolling_iterable(['value', 'lineno', 'col_offset'])
def Expr_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Expr, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("Expr constructor takes 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Expr_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Expr_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Expr.typedef = typedef.TypeDef("Expr",
    stmt.typedef,
    _fields=_FieldsWrapper(['value']),
    value=typedef.GetSetProperty(Expr_get_value, Expr_set_value, cls=Expr),
    __new__=interp2app(get_AST_new(Expr)),
    __init__=interp2app(Expr_init),
)
Expr.typedef.acceptable_as_base_class = False

_Pass_field_unroller = unrolling_iterable(['lineno', 'col_offset'])
def Pass_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Pass, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 2:
            w_err = space.wrap("Pass constructor takes 0 or 2 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Pass_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Pass_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Pass.typedef = typedef.TypeDef("Pass",
    stmt.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(Pass)),
    __init__=interp2app(Pass_init),
)
Pass.typedef.acceptable_as_base_class = False

_Break_field_unroller = unrolling_iterable(['lineno', 'col_offset'])
def Break_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Break, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 2:
            w_err = space.wrap("Break constructor takes 0 or 2 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Break_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Break_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Break.typedef = typedef.TypeDef("Break",
    stmt.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(Break)),
    __init__=interp2app(Break_init),
)
Break.typedef.acceptable_as_base_class = False

_Continue_field_unroller = unrolling_iterable(['lineno', 'col_offset'])
def Continue_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Continue, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 2:
            w_err = space.wrap("Continue constructor takes 0 or 2 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Continue_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Continue_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Continue.typedef = typedef.TypeDef("Continue",
    stmt.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(Continue)),
    __init__=interp2app(Continue_init),
)
Continue.typedef.acceptable_as_base_class = False

def expr_get_lineno(space, w_self):
    if not w_self.initialization_state & w_self._lineno_mask:
        w_err = space.wrap("attribute 'lineno' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.lineno)

def expr_set_lineno(space, w_self, w_new_value):
    w_self.lineno = space.int_w(w_new_value)
    w_self.initialization_state |= w_self._lineno_mask

def expr_get_col_offset(space, w_self):
    if not w_self.initialization_state & w_self._col_offset_mask:
        w_err = space.wrap("attribute 'col_offset' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.col_offset)

def expr_set_col_offset(space, w_self, w_new_value):
    w_self.col_offset = space.int_w(w_new_value)
    w_self.initialization_state |= w_self._col_offset_mask

expr.typedef = typedef.TypeDef("expr",
    AST.typedef,
    _attributes=_FieldsWrapper(['lineno', 'col_offset']),
    lineno=typedef.GetSetProperty(expr_get_lineno, expr_set_lineno, cls=expr),
    col_offset=typedef.GetSetProperty(expr_get_col_offset, expr_set_col_offset, cls=expr),
)
expr.typedef.acceptable_as_base_class = False

def BoolOp_get_op(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'op' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return boolop_to_class[w_self.op - 1]()

def BoolOp_set_op(space, w_self, w_new_value):
    obj = space.interp_w(boolop, w_new_value)
    w_self.op = obj.to_simple_int(space)
    w_self.initialization_state |= 1

def BoolOp_get_values(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'values' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_values is None:
        if w_self.values is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.values]
            w_list = space.newlist(list_w)
        w_self.w_values = w_list
    return w_self.w_values

def BoolOp_set_values(space, w_self, w_new_value):
    w_self.w_values = w_new_value
    w_self.initialization_state |= 2

_BoolOp_field_unroller = unrolling_iterable(['op', 'values', 'lineno', 'col_offset'])
def BoolOp_init(space, w_self, args):
    w_self = space.descr_self_interp_w(BoolOp, w_self)
    w_self.w_values = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 4:
            w_err = space.wrap("BoolOp constructor takes 0 or 4 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _BoolOp_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
BoolOp_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

BoolOp.typedef = typedef.TypeDef("BoolOp",
    expr.typedef,
    _fields=_FieldsWrapper(['op', 'values']),
    op=typedef.GetSetProperty(BoolOp_get_op, BoolOp_set_op, cls=BoolOp),
    values=typedef.GetSetProperty(BoolOp_get_values, BoolOp_set_values, cls=BoolOp),
    __new__=interp2app(get_AST_new(BoolOp)),
    __init__=interp2app(BoolOp_init),
)
BoolOp.typedef.acceptable_as_base_class = False

def BinOp_get_left(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'left' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.left)

def BinOp_set_left(space, w_self, w_new_value):
    w_self.left = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 1

def BinOp_get_op(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'op' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return operator_to_class[w_self.op - 1]()

def BinOp_set_op(space, w_self, w_new_value):
    obj = space.interp_w(operator, w_new_value)
    w_self.op = obj.to_simple_int(space)
    w_self.initialization_state |= 2

def BinOp_get_right(space, w_self):
    if not w_self.initialization_state & 4:
        w_err = space.wrap("attribute 'right' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.right)

def BinOp_set_right(space, w_self, w_new_value):
    w_self.right = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 4

_BinOp_field_unroller = unrolling_iterable(['left', 'op', 'right', 'lineno', 'col_offset'])
def BinOp_init(space, w_self, args):
    w_self = space.descr_self_interp_w(BinOp, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 5:
            w_err = space.wrap("BinOp constructor takes 0 or 5 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _BinOp_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
BinOp_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

BinOp.typedef = typedef.TypeDef("BinOp",
    expr.typedef,
    _fields=_FieldsWrapper(['left', 'op', 'right']),
    left=typedef.GetSetProperty(BinOp_get_left, BinOp_set_left, cls=BinOp),
    op=typedef.GetSetProperty(BinOp_get_op, BinOp_set_op, cls=BinOp),
    right=typedef.GetSetProperty(BinOp_get_right, BinOp_set_right, cls=BinOp),
    __new__=interp2app(get_AST_new(BinOp)),
    __init__=interp2app(BinOp_init),
)
BinOp.typedef.acceptable_as_base_class = False

def UnaryOp_get_op(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'op' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return unaryop_to_class[w_self.op - 1]()

def UnaryOp_set_op(space, w_self, w_new_value):
    obj = space.interp_w(unaryop, w_new_value)
    w_self.op = obj.to_simple_int(space)
    w_self.initialization_state |= 1

def UnaryOp_get_operand(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'operand' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.operand)

def UnaryOp_set_operand(space, w_self, w_new_value):
    w_self.operand = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 2

_UnaryOp_field_unroller = unrolling_iterable(['op', 'operand', 'lineno', 'col_offset'])
def UnaryOp_init(space, w_self, args):
    w_self = space.descr_self_interp_w(UnaryOp, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 4:
            w_err = space.wrap("UnaryOp constructor takes 0 or 4 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _UnaryOp_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
UnaryOp_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

UnaryOp.typedef = typedef.TypeDef("UnaryOp",
    expr.typedef,
    _fields=_FieldsWrapper(['op', 'operand']),
    op=typedef.GetSetProperty(UnaryOp_get_op, UnaryOp_set_op, cls=UnaryOp),
    operand=typedef.GetSetProperty(UnaryOp_get_operand, UnaryOp_set_operand, cls=UnaryOp),
    __new__=interp2app(get_AST_new(UnaryOp)),
    __init__=interp2app(UnaryOp_init),
)
UnaryOp.typedef.acceptable_as_base_class = False

def Lambda_get_args(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'args' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.args)

def Lambda_set_args(space, w_self, w_new_value):
    w_self.args = space.interp_w(arguments, w_new_value, False)
    w_self.initialization_state |= 1

def Lambda_get_body(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'body' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.body)

def Lambda_set_body(space, w_self, w_new_value):
    w_self.body = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 2

_Lambda_field_unroller = unrolling_iterable(['args', 'body', 'lineno', 'col_offset'])
def Lambda_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Lambda, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 4:
            w_err = space.wrap("Lambda constructor takes 0 or 4 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Lambda_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Lambda_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Lambda.typedef = typedef.TypeDef("Lambda",
    expr.typedef,
    _fields=_FieldsWrapper(['args', 'body']),
    args=typedef.GetSetProperty(Lambda_get_args, Lambda_set_args, cls=Lambda),
    body=typedef.GetSetProperty(Lambda_get_body, Lambda_set_body, cls=Lambda),
    __new__=interp2app(get_AST_new(Lambda)),
    __init__=interp2app(Lambda_init),
)
Lambda.typedef.acceptable_as_base_class = False

def IfExp_get_test(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'test' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.test)

def IfExp_set_test(space, w_self, w_new_value):
    w_self.test = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 1

def IfExp_get_body(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'body' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.body)

def IfExp_set_body(space, w_self, w_new_value):
    w_self.body = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 2

def IfExp_get_orelse(space, w_self):
    if not w_self.initialization_state & 4:
        w_err = space.wrap("attribute 'orelse' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.orelse)

def IfExp_set_orelse(space, w_self, w_new_value):
    w_self.orelse = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 4

_IfExp_field_unroller = unrolling_iterable(['test', 'body', 'orelse', 'lineno', 'col_offset'])
def IfExp_init(space, w_self, args):
    w_self = space.descr_self_interp_w(IfExp, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 5:
            w_err = space.wrap("IfExp constructor takes 0 or 5 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _IfExp_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
IfExp_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

IfExp.typedef = typedef.TypeDef("IfExp",
    expr.typedef,
    _fields=_FieldsWrapper(['test', 'body', 'orelse']),
    test=typedef.GetSetProperty(IfExp_get_test, IfExp_set_test, cls=IfExp),
    body=typedef.GetSetProperty(IfExp_get_body, IfExp_set_body, cls=IfExp),
    orelse=typedef.GetSetProperty(IfExp_get_orelse, IfExp_set_orelse, cls=IfExp),
    __new__=interp2app(get_AST_new(IfExp)),
    __init__=interp2app(IfExp_init),
)
IfExp.typedef.acceptable_as_base_class = False

def Dict_get_keys(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'keys' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_keys is None:
        if w_self.keys is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.keys]
            w_list = space.newlist(list_w)
        w_self.w_keys = w_list
    return w_self.w_keys

def Dict_set_keys(space, w_self, w_new_value):
    w_self.w_keys = w_new_value
    w_self.initialization_state |= 1

def Dict_get_values(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'values' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_values is None:
        if w_self.values is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.values]
            w_list = space.newlist(list_w)
        w_self.w_values = w_list
    return w_self.w_values

def Dict_set_values(space, w_self, w_new_value):
    w_self.w_values = w_new_value
    w_self.initialization_state |= 2

_Dict_field_unroller = unrolling_iterable(['keys', 'values', 'lineno', 'col_offset'])
def Dict_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Dict, w_self)
    w_self.w_keys = None
    w_self.w_values = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 4:
            w_err = space.wrap("Dict constructor takes 0 or 4 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Dict_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Dict_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Dict.typedef = typedef.TypeDef("Dict",
    expr.typedef,
    _fields=_FieldsWrapper(['keys', 'values']),
    keys=typedef.GetSetProperty(Dict_get_keys, Dict_set_keys, cls=Dict),
    values=typedef.GetSetProperty(Dict_get_values, Dict_set_values, cls=Dict),
    __new__=interp2app(get_AST_new(Dict)),
    __init__=interp2app(Dict_init),
)
Dict.typedef.acceptable_as_base_class = False

def ListComp_get_elt(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'elt' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.elt)

def ListComp_set_elt(space, w_self, w_new_value):
    w_self.elt = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 1

def ListComp_get_generators(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'generators' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_generators is None:
        if w_self.generators is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.generators]
            w_list = space.newlist(list_w)
        w_self.w_generators = w_list
    return w_self.w_generators

def ListComp_set_generators(space, w_self, w_new_value):
    w_self.w_generators = w_new_value
    w_self.initialization_state |= 2

_ListComp_field_unroller = unrolling_iterable(['elt', 'generators', 'lineno', 'col_offset'])
def ListComp_init(space, w_self, args):
    w_self = space.descr_self_interp_w(ListComp, w_self)
    w_self.w_generators = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 4:
            w_err = space.wrap("ListComp constructor takes 0 or 4 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _ListComp_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
ListComp_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

ListComp.typedef = typedef.TypeDef("ListComp",
    expr.typedef,
    _fields=_FieldsWrapper(['elt', 'generators']),
    elt=typedef.GetSetProperty(ListComp_get_elt, ListComp_set_elt, cls=ListComp),
    generators=typedef.GetSetProperty(ListComp_get_generators, ListComp_set_generators, cls=ListComp),
    __new__=interp2app(get_AST_new(ListComp)),
    __init__=interp2app(ListComp_init),
)
ListComp.typedef.acceptable_as_base_class = False

def GeneratorExp_get_elt(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'elt' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.elt)

def GeneratorExp_set_elt(space, w_self, w_new_value):
    w_self.elt = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 1

def GeneratorExp_get_generators(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'generators' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_generators is None:
        if w_self.generators is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.generators]
            w_list = space.newlist(list_w)
        w_self.w_generators = w_list
    return w_self.w_generators

def GeneratorExp_set_generators(space, w_self, w_new_value):
    w_self.w_generators = w_new_value
    w_self.initialization_state |= 2

_GeneratorExp_field_unroller = unrolling_iterable(['elt', 'generators', 'lineno', 'col_offset'])
def GeneratorExp_init(space, w_self, args):
    w_self = space.descr_self_interp_w(GeneratorExp, w_self)
    w_self.w_generators = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 4:
            w_err = space.wrap("GeneratorExp constructor takes 0 or 4 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _GeneratorExp_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
GeneratorExp_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

GeneratorExp.typedef = typedef.TypeDef("GeneratorExp",
    expr.typedef,
    _fields=_FieldsWrapper(['elt', 'generators']),
    elt=typedef.GetSetProperty(GeneratorExp_get_elt, GeneratorExp_set_elt, cls=GeneratorExp),
    generators=typedef.GetSetProperty(GeneratorExp_get_generators, GeneratorExp_set_generators, cls=GeneratorExp),
    __new__=interp2app(get_AST_new(GeneratorExp)),
    __init__=interp2app(GeneratorExp_init),
)
GeneratorExp.typedef.acceptable_as_base_class = False

def Yield_get_value(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'value' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.value)

def Yield_set_value(space, w_self, w_new_value):
    w_self.value = space.interp_w(expr, w_new_value, True)
    w_self.initialization_state |= 1

_Yield_field_unroller = unrolling_iterable(['value', 'lineno', 'col_offset'])
def Yield_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Yield, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("Yield constructor takes 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Yield_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Yield_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Yield.typedef = typedef.TypeDef("Yield",
    expr.typedef,
    _fields=_FieldsWrapper(['value']),
    value=typedef.GetSetProperty(Yield_get_value, Yield_set_value, cls=Yield),
    __new__=interp2app(get_AST_new(Yield)),
    __init__=interp2app(Yield_init),
)
Yield.typedef.acceptable_as_base_class = False

def Compare_get_left(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'left' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.left)

def Compare_set_left(space, w_self, w_new_value):
    w_self.left = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 1

def Compare_get_ops(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'ops' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_ops is None:
        if w_self.ops is None:
            w_list = space.newlist([])
        else:
            list_w = [cmpop_to_class[node - 1]() for node in w_self.ops]
            w_list = space.newlist(list_w)
        w_self.w_ops = w_list
    return w_self.w_ops

def Compare_set_ops(space, w_self, w_new_value):
    w_self.w_ops = w_new_value
    w_self.initialization_state |= 2

def Compare_get_comparators(space, w_self):
    if not w_self.initialization_state & 4:
        w_err = space.wrap("attribute 'comparators' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_comparators is None:
        if w_self.comparators is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.comparators]
            w_list = space.newlist(list_w)
        w_self.w_comparators = w_list
    return w_self.w_comparators

def Compare_set_comparators(space, w_self, w_new_value):
    w_self.w_comparators = w_new_value
    w_self.initialization_state |= 4

_Compare_field_unroller = unrolling_iterable(['left', 'ops', 'comparators', 'lineno', 'col_offset'])
def Compare_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Compare, w_self)
    w_self.w_ops = None
    w_self.w_comparators = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 5:
            w_err = space.wrap("Compare constructor takes 0 or 5 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Compare_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Compare_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Compare.typedef = typedef.TypeDef("Compare",
    expr.typedef,
    _fields=_FieldsWrapper(['left', 'ops', 'comparators']),
    left=typedef.GetSetProperty(Compare_get_left, Compare_set_left, cls=Compare),
    ops=typedef.GetSetProperty(Compare_get_ops, Compare_set_ops, cls=Compare),
    comparators=typedef.GetSetProperty(Compare_get_comparators, Compare_set_comparators, cls=Compare),
    __new__=interp2app(get_AST_new(Compare)),
    __init__=interp2app(Compare_init),
)
Compare.typedef.acceptable_as_base_class = False

def Call_get_func(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'func' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.func)

def Call_set_func(space, w_self, w_new_value):
    w_self.func = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 1

def Call_get_args(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'args' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_args is None:
        if w_self.args is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.args]
            w_list = space.newlist(list_w)
        w_self.w_args = w_list
    return w_self.w_args

def Call_set_args(space, w_self, w_new_value):
    w_self.w_args = w_new_value
    w_self.initialization_state |= 2

def Call_get_keywords(space, w_self):
    if not w_self.initialization_state & 4:
        w_err = space.wrap("attribute 'keywords' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_keywords is None:
        if w_self.keywords is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.keywords]
            w_list = space.newlist(list_w)
        w_self.w_keywords = w_list
    return w_self.w_keywords

def Call_set_keywords(space, w_self, w_new_value):
    w_self.w_keywords = w_new_value
    w_self.initialization_state |= 4

def Call_get_starargs(space, w_self):
    if not w_self.initialization_state & 8:
        w_err = space.wrap("attribute 'starargs' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.starargs)

def Call_set_starargs(space, w_self, w_new_value):
    w_self.starargs = space.interp_w(expr, w_new_value, True)
    w_self.initialization_state |= 8

def Call_get_kwargs(space, w_self):
    if not w_self.initialization_state & 16:
        w_err = space.wrap("attribute 'kwargs' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.kwargs)

def Call_set_kwargs(space, w_self, w_new_value):
    w_self.kwargs = space.interp_w(expr, w_new_value, True)
    w_self.initialization_state |= 16

_Call_field_unroller = unrolling_iterable(['func', 'args', 'keywords', 'starargs', 'kwargs', 'lineno', 'col_offset'])
def Call_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Call, w_self)
    w_self.w_args = None
    w_self.w_keywords = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 7:
            w_err = space.wrap("Call constructor takes 0 or 7 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Call_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Call_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Call.typedef = typedef.TypeDef("Call",
    expr.typedef,
    _fields=_FieldsWrapper(['func', 'args', 'keywords', 'starargs', 'kwargs']),
    func=typedef.GetSetProperty(Call_get_func, Call_set_func, cls=Call),
    args=typedef.GetSetProperty(Call_get_args, Call_set_args, cls=Call),
    keywords=typedef.GetSetProperty(Call_get_keywords, Call_set_keywords, cls=Call),
    starargs=typedef.GetSetProperty(Call_get_starargs, Call_set_starargs, cls=Call),
    kwargs=typedef.GetSetProperty(Call_get_kwargs, Call_set_kwargs, cls=Call),
    __new__=interp2app(get_AST_new(Call)),
    __init__=interp2app(Call_init),
)
Call.typedef.acceptable_as_base_class = False

def Repr_get_value(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'value' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.value)

def Repr_set_value(space, w_self, w_new_value):
    w_self.value = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 1

_Repr_field_unroller = unrolling_iterable(['value', 'lineno', 'col_offset'])
def Repr_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Repr, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("Repr constructor takes 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Repr_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Repr_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Repr.typedef = typedef.TypeDef("Repr",
    expr.typedef,
    _fields=_FieldsWrapper(['value']),
    value=typedef.GetSetProperty(Repr_get_value, Repr_set_value, cls=Repr),
    __new__=interp2app(get_AST_new(Repr)),
    __init__=interp2app(Repr_init),
)
Repr.typedef.acceptable_as_base_class = False

def Num_get_n(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'n' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return w_self.n

def Num_set_n(space, w_self, w_new_value):
    w_self.n = w_new_value
    w_self.initialization_state |= 1

_Num_field_unroller = unrolling_iterable(['n', 'lineno', 'col_offset'])
def Num_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Num, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("Num constructor takes 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Num_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Num_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Num.typedef = typedef.TypeDef("Num",
    expr.typedef,
    _fields=_FieldsWrapper(['n']),
    n=typedef.GetSetProperty(Num_get_n, Num_set_n, cls=Num),
    __new__=interp2app(get_AST_new(Num)),
    __init__=interp2app(Num_init),
)
Num.typedef.acceptable_as_base_class = False

def Str_get_s(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 's' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return w_self.s

def Str_set_s(space, w_self, w_new_value):
    if not space.is_true(space.isinstance(w_new_value, space.w_basestring)):
        w_err = space.wrap("some kind of string required")
        raise OperationError(space.w_TypeError, w_err)
    w_self.s = w_new_value
    w_self.initialization_state |= 1

_Str_field_unroller = unrolling_iterable(['s', 'lineno', 'col_offset'])
def Str_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Str, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("Str constructor takes 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Str_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Str_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Str.typedef = typedef.TypeDef("Str",
    expr.typedef,
    _fields=_FieldsWrapper(['s']),
    s=typedef.GetSetProperty(Str_get_s, Str_set_s, cls=Str),
    __new__=interp2app(get_AST_new(Str)),
    __init__=interp2app(Str_init),
)
Str.typedef.acceptable_as_base_class = False

def Attribute_get_value(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'value' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.value)

def Attribute_set_value(space, w_self, w_new_value):
    w_self.value = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 1

def Attribute_get_attr(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'attr' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.attr)

def Attribute_set_attr(space, w_self, w_new_value):
    w_self.attr = space.str_w(w_new_value)
    w_self.initialization_state |= 2

def Attribute_get_ctx(space, w_self):
    if not w_self.initialization_state & 4:
        w_err = space.wrap("attribute 'ctx' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return expr_context_to_class[w_self.ctx - 1]()

def Attribute_set_ctx(space, w_self, w_new_value):
    obj = space.interp_w(expr_context, w_new_value)
    w_self.ctx = obj.to_simple_int(space)
    w_self.initialization_state |= 4

_Attribute_field_unroller = unrolling_iterable(['value', 'attr', 'ctx', 'lineno', 'col_offset'])
def Attribute_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Attribute, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 5:
            w_err = space.wrap("Attribute constructor takes 0 or 5 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Attribute_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Attribute_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Attribute.typedef = typedef.TypeDef("Attribute",
    expr.typedef,
    _fields=_FieldsWrapper(['value', 'attr', 'ctx']),
    value=typedef.GetSetProperty(Attribute_get_value, Attribute_set_value, cls=Attribute),
    attr=typedef.GetSetProperty(Attribute_get_attr, Attribute_set_attr, cls=Attribute),
    ctx=typedef.GetSetProperty(Attribute_get_ctx, Attribute_set_ctx, cls=Attribute),
    __new__=interp2app(get_AST_new(Attribute)),
    __init__=interp2app(Attribute_init),
)
Attribute.typedef.acceptable_as_base_class = False

def Subscript_get_value(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'value' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.value)

def Subscript_set_value(space, w_self, w_new_value):
    w_self.value = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 1

def Subscript_get_slice(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'slice' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.slice)

def Subscript_set_slice(space, w_self, w_new_value):
    w_self.slice = space.interp_w(slice, w_new_value, False)
    w_self.initialization_state |= 2

def Subscript_get_ctx(space, w_self):
    if not w_self.initialization_state & 4:
        w_err = space.wrap("attribute 'ctx' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return expr_context_to_class[w_self.ctx - 1]()

def Subscript_set_ctx(space, w_self, w_new_value):
    obj = space.interp_w(expr_context, w_new_value)
    w_self.ctx = obj.to_simple_int(space)
    w_self.initialization_state |= 4

_Subscript_field_unroller = unrolling_iterable(['value', 'slice', 'ctx', 'lineno', 'col_offset'])
def Subscript_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Subscript, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 5:
            w_err = space.wrap("Subscript constructor takes 0 or 5 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Subscript_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Subscript_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Subscript.typedef = typedef.TypeDef("Subscript",
    expr.typedef,
    _fields=_FieldsWrapper(['value', 'slice', 'ctx']),
    value=typedef.GetSetProperty(Subscript_get_value, Subscript_set_value, cls=Subscript),
    slice=typedef.GetSetProperty(Subscript_get_slice, Subscript_set_slice, cls=Subscript),
    ctx=typedef.GetSetProperty(Subscript_get_ctx, Subscript_set_ctx, cls=Subscript),
    __new__=interp2app(get_AST_new(Subscript)),
    __init__=interp2app(Subscript_init),
)
Subscript.typedef.acceptable_as_base_class = False

def Name_get_id(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'id' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.id)

def Name_set_id(space, w_self, w_new_value):
    w_self.id = space.str_w(w_new_value)
    w_self.initialization_state |= 1

def Name_get_ctx(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'ctx' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return expr_context_to_class[w_self.ctx - 1]()

def Name_set_ctx(space, w_self, w_new_value):
    obj = space.interp_w(expr_context, w_new_value)
    w_self.ctx = obj.to_simple_int(space)
    w_self.initialization_state |= 2

_Name_field_unroller = unrolling_iterable(['id', 'ctx', 'lineno', 'col_offset'])
def Name_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Name, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 4:
            w_err = space.wrap("Name constructor takes 0 or 4 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Name_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Name_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Name.typedef = typedef.TypeDef("Name",
    expr.typedef,
    _fields=_FieldsWrapper(['id', 'ctx']),
    id=typedef.GetSetProperty(Name_get_id, Name_set_id, cls=Name),
    ctx=typedef.GetSetProperty(Name_get_ctx, Name_set_ctx, cls=Name),
    __new__=interp2app(get_AST_new(Name)),
    __init__=interp2app(Name_init),
)
Name.typedef.acceptable_as_base_class = False

def List_get_elts(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'elts' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_elts is None:
        if w_self.elts is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.elts]
            w_list = space.newlist(list_w)
        w_self.w_elts = w_list
    return w_self.w_elts

def List_set_elts(space, w_self, w_new_value):
    w_self.w_elts = w_new_value
    w_self.initialization_state |= 1

def List_get_ctx(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'ctx' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return expr_context_to_class[w_self.ctx - 1]()

def List_set_ctx(space, w_self, w_new_value):
    obj = space.interp_w(expr_context, w_new_value)
    w_self.ctx = obj.to_simple_int(space)
    w_self.initialization_state |= 2

_List_field_unroller = unrolling_iterable(['elts', 'ctx', 'lineno', 'col_offset'])
def List_init(space, w_self, args):
    w_self = space.descr_self_interp_w(List, w_self)
    w_self.w_elts = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 4:
            w_err = space.wrap("List constructor takes 0 or 4 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _List_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
List_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

List.typedef = typedef.TypeDef("List",
    expr.typedef,
    _fields=_FieldsWrapper(['elts', 'ctx']),
    elts=typedef.GetSetProperty(List_get_elts, List_set_elts, cls=List),
    ctx=typedef.GetSetProperty(List_get_ctx, List_set_ctx, cls=List),
    __new__=interp2app(get_AST_new(List)),
    __init__=interp2app(List_init),
)
List.typedef.acceptable_as_base_class = False

def Tuple_get_elts(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'elts' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_elts is None:
        if w_self.elts is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.elts]
            w_list = space.newlist(list_w)
        w_self.w_elts = w_list
    return w_self.w_elts

def Tuple_set_elts(space, w_self, w_new_value):
    w_self.w_elts = w_new_value
    w_self.initialization_state |= 1

def Tuple_get_ctx(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'ctx' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return expr_context_to_class[w_self.ctx - 1]()

def Tuple_set_ctx(space, w_self, w_new_value):
    obj = space.interp_w(expr_context, w_new_value)
    w_self.ctx = obj.to_simple_int(space)
    w_self.initialization_state |= 2

_Tuple_field_unroller = unrolling_iterable(['elts', 'ctx', 'lineno', 'col_offset'])
def Tuple_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Tuple, w_self)
    w_self.w_elts = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 4:
            w_err = space.wrap("Tuple constructor takes 0 or 4 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Tuple_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Tuple_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Tuple.typedef = typedef.TypeDef("Tuple",
    expr.typedef,
    _fields=_FieldsWrapper(['elts', 'ctx']),
    elts=typedef.GetSetProperty(Tuple_get_elts, Tuple_set_elts, cls=Tuple),
    ctx=typedef.GetSetProperty(Tuple_get_ctx, Tuple_set_ctx, cls=Tuple),
    __new__=interp2app(get_AST_new(Tuple)),
    __init__=interp2app(Tuple_init),
)
Tuple.typedef.acceptable_as_base_class = False

def Const_get_value(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'value' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return w_self.value

def Const_set_value(space, w_self, w_new_value):
    w_self.value = w_new_value
    w_self.initialization_state |= 1

_Const_field_unroller = unrolling_iterable(['value', 'lineno', 'col_offset'])
def Const_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Const, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("Const constructor takes 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Const_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Const_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Const.typedef = typedef.TypeDef("Const",
    expr.typedef,
    _fields=_FieldsWrapper(['value']),
    value=typedef.GetSetProperty(Const_get_value, Const_set_value, cls=Const),
    __new__=interp2app(get_AST_new(Const)),
    __init__=interp2app(Const_init),
)
Const.typedef.acceptable_as_base_class = False

expr_context.typedef = typedef.TypeDef("expr_context",
    AST.typedef,
    _attributes=_FieldsWrapper([]),
)
expr_context.typedef.acceptable_as_base_class = False

_Load.typedef = typedef.TypeDef("Load",
    expr_context.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Load)),
)
_Load.typedef.acceptable_as_base_class = False

_Store.typedef = typedef.TypeDef("Store",
    expr_context.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Store)),
)
_Store.typedef.acceptable_as_base_class = False

_Del.typedef = typedef.TypeDef("Del",
    expr_context.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Del)),
)
_Del.typedef.acceptable_as_base_class = False

_AugLoad.typedef = typedef.TypeDef("AugLoad",
    expr_context.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_AugLoad)),
)
_AugLoad.typedef.acceptable_as_base_class = False

_AugStore.typedef = typedef.TypeDef("AugStore",
    expr_context.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_AugStore)),
)
_AugStore.typedef.acceptable_as_base_class = False

_Param.typedef = typedef.TypeDef("Param",
    expr_context.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Param)),
)
_Param.typedef.acceptable_as_base_class = False

slice.typedef = typedef.TypeDef("slice",
    AST.typedef,
    _attributes=_FieldsWrapper([]),
)
slice.typedef.acceptable_as_base_class = False

_Ellipsis_field_unroller = unrolling_iterable([])
def Ellipsis_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Ellipsis, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        w_err = space.wrap("Ellipsis constructor takes no  arguments")
        raise OperationError(space.w_TypeError, w_err)
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Ellipsis_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Ellipsis.typedef = typedef.TypeDef("Ellipsis",
    slice.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(Ellipsis)),
    __init__=interp2app(Ellipsis_init),
)
Ellipsis.typedef.acceptable_as_base_class = False

def Slice_get_lower(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'lower' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.lower)

def Slice_set_lower(space, w_self, w_new_value):
    w_self.lower = space.interp_w(expr, w_new_value, True)
    w_self.initialization_state |= 1

def Slice_get_upper(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'upper' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.upper)

def Slice_set_upper(space, w_self, w_new_value):
    w_self.upper = space.interp_w(expr, w_new_value, True)
    w_self.initialization_state |= 2

def Slice_get_step(space, w_self):
    if not w_self.initialization_state & 4:
        w_err = space.wrap("attribute 'step' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.step)

def Slice_set_step(space, w_self, w_new_value):
    w_self.step = space.interp_w(expr, w_new_value, True)
    w_self.initialization_state |= 4

_Slice_field_unroller = unrolling_iterable(['lower', 'upper', 'step'])
def Slice_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Slice, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("Slice constructor takes 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Slice_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Slice_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Slice.typedef = typedef.TypeDef("Slice",
    slice.typedef,
    _fields=_FieldsWrapper(['lower', 'upper', 'step']),
    lower=typedef.GetSetProperty(Slice_get_lower, Slice_set_lower, cls=Slice),
    upper=typedef.GetSetProperty(Slice_get_upper, Slice_set_upper, cls=Slice),
    step=typedef.GetSetProperty(Slice_get_step, Slice_set_step, cls=Slice),
    __new__=interp2app(get_AST_new(Slice)),
    __init__=interp2app(Slice_init),
)
Slice.typedef.acceptable_as_base_class = False

def ExtSlice_get_dims(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'dims' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_dims is None:
        if w_self.dims is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.dims]
            w_list = space.newlist(list_w)
        w_self.w_dims = w_list
    return w_self.w_dims

def ExtSlice_set_dims(space, w_self, w_new_value):
    w_self.w_dims = w_new_value
    w_self.initialization_state |= 1

_ExtSlice_field_unroller = unrolling_iterable(['dims'])
def ExtSlice_init(space, w_self, args):
    w_self = space.descr_self_interp_w(ExtSlice, w_self)
    w_self.w_dims = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 1:
            w_err = space.wrap("ExtSlice constructor takes 0 or 1 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _ExtSlice_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
ExtSlice_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

ExtSlice.typedef = typedef.TypeDef("ExtSlice",
    slice.typedef,
    _fields=_FieldsWrapper(['dims']),
    dims=typedef.GetSetProperty(ExtSlice_get_dims, ExtSlice_set_dims, cls=ExtSlice),
    __new__=interp2app(get_AST_new(ExtSlice)),
    __init__=interp2app(ExtSlice_init),
)
ExtSlice.typedef.acceptable_as_base_class = False

def Index_get_value(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'value' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.value)

def Index_set_value(space, w_self, w_new_value):
    w_self.value = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 1

_Index_field_unroller = unrolling_iterable(['value'])
def Index_init(space, w_self, args):
    w_self = space.descr_self_interp_w(Index, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 1:
            w_err = space.wrap("Index constructor takes 0 or 1 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _Index_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
Index_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

Index.typedef = typedef.TypeDef("Index",
    slice.typedef,
    _fields=_FieldsWrapper(['value']),
    value=typedef.GetSetProperty(Index_get_value, Index_set_value, cls=Index),
    __new__=interp2app(get_AST_new(Index)),
    __init__=interp2app(Index_init),
)
Index.typedef.acceptable_as_base_class = False

boolop.typedef = typedef.TypeDef("boolop",
    AST.typedef,
    _attributes=_FieldsWrapper([]),
)
boolop.typedef.acceptable_as_base_class = False

_And.typedef = typedef.TypeDef("And",
    boolop.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_And)),
)
_And.typedef.acceptable_as_base_class = False

_Or.typedef = typedef.TypeDef("Or",
    boolop.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Or)),
)
_Or.typedef.acceptable_as_base_class = False

operator.typedef = typedef.TypeDef("operator",
    AST.typedef,
    _attributes=_FieldsWrapper([]),
)
operator.typedef.acceptable_as_base_class = False

_Add.typedef = typedef.TypeDef("Add",
    operator.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Add)),
)
_Add.typedef.acceptable_as_base_class = False

_Sub.typedef = typedef.TypeDef("Sub",
    operator.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Sub)),
)
_Sub.typedef.acceptable_as_base_class = False

_Mult.typedef = typedef.TypeDef("Mult",
    operator.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Mult)),
)
_Mult.typedef.acceptable_as_base_class = False

_Div.typedef = typedef.TypeDef("Div",
    operator.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Div)),
)
_Div.typedef.acceptable_as_base_class = False

_Mod.typedef = typedef.TypeDef("Mod",
    operator.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Mod)),
)
_Mod.typedef.acceptable_as_base_class = False

_Pow.typedef = typedef.TypeDef("Pow",
    operator.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Pow)),
)
_Pow.typedef.acceptable_as_base_class = False

_LShift.typedef = typedef.TypeDef("LShift",
    operator.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_LShift)),
)
_LShift.typedef.acceptable_as_base_class = False

_RShift.typedef = typedef.TypeDef("RShift",
    operator.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_RShift)),
)
_RShift.typedef.acceptable_as_base_class = False

_BitOr.typedef = typedef.TypeDef("BitOr",
    operator.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_BitOr)),
)
_BitOr.typedef.acceptable_as_base_class = False

_BitXor.typedef = typedef.TypeDef("BitXor",
    operator.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_BitXor)),
)
_BitXor.typedef.acceptable_as_base_class = False

_BitAnd.typedef = typedef.TypeDef("BitAnd",
    operator.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_BitAnd)),
)
_BitAnd.typedef.acceptable_as_base_class = False

_FloorDiv.typedef = typedef.TypeDef("FloorDiv",
    operator.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_FloorDiv)),
)
_FloorDiv.typedef.acceptable_as_base_class = False

unaryop.typedef = typedef.TypeDef("unaryop",
    AST.typedef,
    _attributes=_FieldsWrapper([]),
)
unaryop.typedef.acceptable_as_base_class = False

_Invert.typedef = typedef.TypeDef("Invert",
    unaryop.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Invert)),
)
_Invert.typedef.acceptable_as_base_class = False

_Not.typedef = typedef.TypeDef("Not",
    unaryop.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Not)),
)
_Not.typedef.acceptable_as_base_class = False

_UAdd.typedef = typedef.TypeDef("UAdd",
    unaryop.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_UAdd)),
)
_UAdd.typedef.acceptable_as_base_class = False

_USub.typedef = typedef.TypeDef("USub",
    unaryop.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_USub)),
)
_USub.typedef.acceptable_as_base_class = False

cmpop.typedef = typedef.TypeDef("cmpop",
    AST.typedef,
    _attributes=_FieldsWrapper([]),
)
cmpop.typedef.acceptable_as_base_class = False

_Eq.typedef = typedef.TypeDef("Eq",
    cmpop.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Eq)),
)
_Eq.typedef.acceptable_as_base_class = False

_NotEq.typedef = typedef.TypeDef("NotEq",
    cmpop.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_NotEq)),
)
_NotEq.typedef.acceptable_as_base_class = False

_Lt.typedef = typedef.TypeDef("Lt",
    cmpop.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Lt)),
)
_Lt.typedef.acceptable_as_base_class = False

_LtE.typedef = typedef.TypeDef("LtE",
    cmpop.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_LtE)),
)
_LtE.typedef.acceptable_as_base_class = False

_Gt.typedef = typedef.TypeDef("Gt",
    cmpop.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Gt)),
)
_Gt.typedef.acceptable_as_base_class = False

_GtE.typedef = typedef.TypeDef("GtE",
    cmpop.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_GtE)),
)
_GtE.typedef.acceptable_as_base_class = False

_Is.typedef = typedef.TypeDef("Is",
    cmpop.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_Is)),
)
_Is.typedef.acceptable_as_base_class = False

_IsNot.typedef = typedef.TypeDef("IsNot",
    cmpop.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_IsNot)),
)
_IsNot.typedef.acceptable_as_base_class = False

_In.typedef = typedef.TypeDef("In",
    cmpop.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_In)),
)
_In.typedef.acceptable_as_base_class = False

_NotIn.typedef = typedef.TypeDef("NotIn",
    cmpop.typedef,
    _fields=_FieldsWrapper([]),
    __new__=interp2app(get_AST_new(_NotIn)),
)
_NotIn.typedef.acceptable_as_base_class = False

def comprehension_get_target(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'target' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.target)

def comprehension_set_target(space, w_self, w_new_value):
    w_self.target = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 1

def comprehension_get_iter(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'iter' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.iter)

def comprehension_set_iter(space, w_self, w_new_value):
    w_self.iter = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 2

def comprehension_get_ifs(space, w_self):
    if not w_self.initialization_state & 4:
        w_err = space.wrap("attribute 'ifs' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_ifs is None:
        if w_self.ifs is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.ifs]
            w_list = space.newlist(list_w)
        w_self.w_ifs = w_list
    return w_self.w_ifs

def comprehension_set_ifs(space, w_self, w_new_value):
    w_self.w_ifs = w_new_value
    w_self.initialization_state |= 4

_comprehension_field_unroller = unrolling_iterable(['target', 'iter', 'ifs'])
def comprehension_init(space, w_self, args):
    w_self = space.descr_self_interp_w(comprehension, w_self)
    w_self.w_ifs = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 3:
            w_err = space.wrap("comprehension constructor takes 0 or 3 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _comprehension_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
comprehension_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

comprehension.typedef = typedef.TypeDef("comprehension",
    AST.typedef,
    _fields=_FieldsWrapper(['target', 'iter', 'ifs']),
    target=typedef.GetSetProperty(comprehension_get_target, comprehension_set_target, cls=comprehension),
    iter=typedef.GetSetProperty(comprehension_get_iter, comprehension_set_iter, cls=comprehension),
    ifs=typedef.GetSetProperty(comprehension_get_ifs, comprehension_set_ifs, cls=comprehension),
    __new__=interp2app(get_AST_new(comprehension)),
    __init__=interp2app(comprehension_init),
)
comprehension.typedef.acceptable_as_base_class = False

def excepthandler_get_type(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'type' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.type)

def excepthandler_set_type(space, w_self, w_new_value):
    w_self.type = space.interp_w(expr, w_new_value, True)
    w_self.initialization_state |= 1

def excepthandler_get_name(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'name' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.name)

def excepthandler_set_name(space, w_self, w_new_value):
    w_self.name = space.interp_w(expr, w_new_value, True)
    w_self.initialization_state |= 2

def excepthandler_get_body(space, w_self):
    if not w_self.initialization_state & 4:
        w_err = space.wrap("attribute 'body' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_body is None:
        if w_self.body is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.body]
            w_list = space.newlist(list_w)
        w_self.w_body = w_list
    return w_self.w_body

def excepthandler_set_body(space, w_self, w_new_value):
    w_self.w_body = w_new_value
    w_self.initialization_state |= 4

def excepthandler_get_lineno(space, w_self):
    if not w_self.initialization_state & 8:
        w_err = space.wrap("attribute 'lineno' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.lineno)

def excepthandler_set_lineno(space, w_self, w_new_value):
    w_self.lineno = space.int_w(w_new_value)
    w_self.initialization_state |= 8

def excepthandler_get_col_offset(space, w_self):
    if not w_self.initialization_state & 16:
        w_err = space.wrap("attribute 'col_offset' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.col_offset)

def excepthandler_set_col_offset(space, w_self, w_new_value):
    w_self.col_offset = space.int_w(w_new_value)
    w_self.initialization_state |= 16

_excepthandler_field_unroller = unrolling_iterable(['type', 'name', 'body', 'lineno', 'col_offset'])
def excepthandler_init(space, w_self, args):
    w_self = space.descr_self_interp_w(excepthandler, w_self)
    w_self.w_body = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 5:
            w_err = space.wrap("excepthandler constructor takes 0 or 5 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _excepthandler_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
excepthandler_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

excepthandler.typedef = typedef.TypeDef("excepthandler",
    AST.typedef,
    _fields=_FieldsWrapper(['type', 'name', 'body', 'lineno', 'col_offset']),
    type=typedef.GetSetProperty(excepthandler_get_type, excepthandler_set_type, cls=excepthandler),
    name=typedef.GetSetProperty(excepthandler_get_name, excepthandler_set_name, cls=excepthandler),
    body=typedef.GetSetProperty(excepthandler_get_body, excepthandler_set_body, cls=excepthandler),
    lineno=typedef.GetSetProperty(excepthandler_get_lineno, excepthandler_set_lineno, cls=excepthandler),
    col_offset=typedef.GetSetProperty(excepthandler_get_col_offset, excepthandler_set_col_offset, cls=excepthandler),
    __new__=interp2app(get_AST_new(excepthandler)),
    __init__=interp2app(excepthandler_init),
)
excepthandler.typedef.acceptable_as_base_class = False

def arguments_get_args(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'args' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_args is None:
        if w_self.args is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.args]
            w_list = space.newlist(list_w)
        w_self.w_args = w_list
    return w_self.w_args

def arguments_set_args(space, w_self, w_new_value):
    w_self.w_args = w_new_value
    w_self.initialization_state |= 1

def arguments_get_vararg(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'vararg' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.vararg)

def arguments_set_vararg(space, w_self, w_new_value):
    if space.is_w(w_new_value, space.w_None):
        w_self.vararg = None
    else:
        w_self.vararg = space.str_w(w_new_value)
    w_self.initialization_state |= 2

def arguments_get_kwarg(space, w_self):
    if not w_self.initialization_state & 4:
        w_err = space.wrap("attribute 'kwarg' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.kwarg)

def arguments_set_kwarg(space, w_self, w_new_value):
    if space.is_w(w_new_value, space.w_None):
        w_self.kwarg = None
    else:
        w_self.kwarg = space.str_w(w_new_value)
    w_self.initialization_state |= 4

def arguments_get_defaults(space, w_self):
    if not w_self.initialization_state & 8:
        w_err = space.wrap("attribute 'defaults' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    if w_self.w_defaults is None:
        if w_self.defaults is None:
            w_list = space.newlist([])
        else:
            list_w = [space.wrap(node) for node in w_self.defaults]
            w_list = space.newlist(list_w)
        w_self.w_defaults = w_list
    return w_self.w_defaults

def arguments_set_defaults(space, w_self, w_new_value):
    w_self.w_defaults = w_new_value
    w_self.initialization_state |= 8

_arguments_field_unroller = unrolling_iterable(['args', 'vararg', 'kwarg', 'defaults'])
def arguments_init(space, w_self, args):
    w_self = space.descr_self_interp_w(arguments, w_self)
    w_self.w_args = None
    w_self.w_defaults = None
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 4:
            w_err = space.wrap("arguments constructor takes 0 or 4 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _arguments_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
arguments_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

arguments.typedef = typedef.TypeDef("arguments",
    AST.typedef,
    _fields=_FieldsWrapper(['args', 'vararg', 'kwarg', 'defaults']),
    args=typedef.GetSetProperty(arguments_get_args, arguments_set_args, cls=arguments),
    vararg=typedef.GetSetProperty(arguments_get_vararg, arguments_set_vararg, cls=arguments),
    kwarg=typedef.GetSetProperty(arguments_get_kwarg, arguments_set_kwarg, cls=arguments),
    defaults=typedef.GetSetProperty(arguments_get_defaults, arguments_set_defaults, cls=arguments),
    __new__=interp2app(get_AST_new(arguments)),
    __init__=interp2app(arguments_init),
)
arguments.typedef.acceptable_as_base_class = False

def keyword_get_arg(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'arg' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.arg)

def keyword_set_arg(space, w_self, w_new_value):
    w_self.arg = space.str_w(w_new_value)
    w_self.initialization_state |= 1

def keyword_get_value(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'value' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.value)

def keyword_set_value(space, w_self, w_new_value):
    w_self.value = space.interp_w(expr, w_new_value, False)
    w_self.initialization_state |= 2

_keyword_field_unroller = unrolling_iterable(['arg', 'value'])
def keyword_init(space, w_self, args):
    w_self = space.descr_self_interp_w(keyword, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 2:
            w_err = space.wrap("keyword constructor takes 0 or 2 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _keyword_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
keyword_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

keyword.typedef = typedef.TypeDef("keyword",
    AST.typedef,
    _fields=_FieldsWrapper(['arg', 'value']),
    arg=typedef.GetSetProperty(keyword_get_arg, keyword_set_arg, cls=keyword),
    value=typedef.GetSetProperty(keyword_get_value, keyword_set_value, cls=keyword),
    __new__=interp2app(get_AST_new(keyword)),
    __init__=interp2app(keyword_init),
)
keyword.typedef.acceptable_as_base_class = False

def alias_get_name(space, w_self):
    if not w_self.initialization_state & 1:
        w_err = space.wrap("attribute 'name' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.name)

def alias_set_name(space, w_self, w_new_value):
    w_self.name = space.str_w(w_new_value)
    w_self.initialization_state |= 1

def alias_get_asname(space, w_self):
    if not w_self.initialization_state & 2:
        w_err = space.wrap("attribute 'asname' has not been set")
        raise OperationError(space.w_AttributeError, w_err)
    return space.wrap(w_self.asname)

def alias_set_asname(space, w_self, w_new_value):
    if space.is_w(w_new_value, space.w_None):
        w_self.asname = None
    else:
        w_self.asname = space.str_w(w_new_value)
    w_self.initialization_state |= 2

_alias_field_unroller = unrolling_iterable(['name', 'asname'])
def alias_init(space, w_self, args):
    w_self = space.descr_self_interp_w(alias, w_self)
    args_w, kwargs_w = args.unpack()
    if args_w:
        if len(args_w) != 2:
            w_err = space.wrap("alias constructor takes 0 or 2 positional arguments")
            raise OperationError(space.w_TypeError, w_err)
        i = 0
        for field in _alias_field_unroller:
            space.setattr(w_self, space.wrap(field), args_w[i])
            i += 1
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)
alias_init.unwrap_spec = [ObjSpace, W_Root, Arguments]

alias.typedef = typedef.TypeDef("alias",
    AST.typedef,
    _fields=_FieldsWrapper(['name', 'asname']),
    name=typedef.GetSetProperty(alias_get_name, alias_set_name, cls=alias),
    asname=typedef.GetSetProperty(alias_get_asname, alias_set_asname, cls=alias),
    __new__=interp2app(get_AST_new(alias)),
    __init__=interp2app(alias_init),
)
alias.typedef.acceptable_as_base_class = False

