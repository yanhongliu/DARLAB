"""
--------

The docstring annotations have the following meanings:

    NAME            Indicates a "stable" name used by callers of a function
                    instead of a generated name which would distinguish
                    different specialisations.

    NATIVE          Means that the class or function body details are not
                    accurate representations of the actual code and should not
                    be generated by a compiler.

    INTERCHANGEABLE Indicates that instances of a class are not sufficiently or
                    meaningfully distinguishable from each other with regard to
                    instantiation.

    SPECIAL         Indicates that the compiler should try and optimise calls to
                    the annotated function.

    ATOMIC          Indicates that the class and its instance(s) cannot store
                    attributes, although some may be predefined (such as the
                    __true__ method).

--------
NATIVE
"""

class boolean:
    """
    NATIVE
    INTERCHANGEABLE
    """
    def __true__(self):
        return self

    def __str__(self):
        if self:
            return "True"
        else:
            return "False"
class none:
    """
    NATIVE
    INTERCHANGEABLE
    """
    def __str__(self):
        return "None"
def abs(x):
    return x.__abs__()
class file:
    def __init__(self):
        pass
    def open(name,mode):
        pass
    def read(self,n = -1):
        return string()
    def close(self):
        pass
    def tell(self):
        return int()
    def fileno(self):
        return int()
    def seek(self, pos, mode = 0):
        """Set the file's current position.

        The mode argument is optional and defaults to 0 (absolute file
        positioning); other values are 1 (seek relative to the current
        position) and 2 (seek relative to the file's end).

        There is no return value.
        """
        pass

    def readline(self, length=None):
        """Read one entire line from the file.

        A trailing newline character is kept in the string (but may be absent
        when a file ends with an incomplete line). If the size argument is
        present and non-negative, it is a maximum byte count (including the
        trailing newline) and an incomplete line may be returned.

        An empty string is returned only when EOF is encountered immediately.

        Note: Unlike stdio's fgets(), the returned string contains null
        characters ('\0') if they occurred in the input.
        """
        return string()

    def readlines(self, sizehint = 0):
        """Read until EOF using readline() and return a list containing the
        lines thus read.

        If the optional sizehint argument is present, instead of reading up
        to EOF, whole lines totalling approximately sizehint bytes (or more
        to accommodate a final whole line).
        """
        return [string()]

    def truncate(self, size=None):
        """Truncate the file's size.

        If the optional size argument is present, the file is truncated to
        (at most) that size. The size defaults to the current position.
        The current file position is not changed unless the position
        is beyond the new file size.

        If the specified size exceeds the file's current size, the
        file remains unchanged.
        """
        pass

    def write(self, s):
        """Write a string to the file.

        There is no return value.
        """
        pass

    def writelines(self, iterable):
        """Write a sequence of strings to the file. The sequence can be any
        iterable object producing strings, typically a list of strings. There
        is no return value.

        (The name is intended to match readlines(); writelines() does not add
        line separators.)
        """
        pass

    def flush(self):
        """Flush the internal buffer
        """
        pass

    def getvalue(self):
        """
        Retrieve the entire contents of the "file" at any time before
        the StringIO object's close() method is called.

        The StringIO object can accept either Unicode or 8-bit strings,
        but mixing the two may take some care. If both are used, 8-bit
        strings that cannot be interpreted as 7-bit ASCII (that use the
        8th bit) will cause a UnicodeError to be raised when getvalue()
        is called.
        """
        return string()

    def __iter__(self):
        return self

    def next(self):
        """A file object is its own iterator, for example iter(f) returns f
        (unless f is closed). When a file is used as an iterator, typically
        in a for loop (for example, for line in f: print line), the next()
        method is called repeatedly. This method returns the next input line,
        or raises StopIteration when EOF is hit.
        """
        return string()
a
def repr(arg):
    return string()

def open(name,mode='r'):
    c=file()
    c.open(name,mode)
    return c

class StackCode:
    def __init__(self):
        self.co_filename=string()
class StackFrame:
    def __init__(self):
        self.f_back=self
        self.f_lineno=int()
        self.f_trace=self
        self.f_code=StackCode()
        pass
def eval(*args):
    if 1:   return string()
    elif 1: return long()
    elif 1: return int()
    elif 1: return none()
    elif 1: return boolean()
    elif 1: return undefined()
    elif 1: return float()
    elif 1: return buffer()
    elif 1: return list()
    elif 1: return tuple()
    elif 1: return dict()
    elif 1: return file()
    

def min(a,b):
    return a
class int:
    """
    NATIVE
    INTERCHANGEABLE
    """
    def __iadd__(self, other):
        """
        NAME: IMPL.builtins.int.__iadd__
        NATIVE
        """
        if isinstance(other, int):
            return int()
        else:
            TypeConstraintError

    def __isub__(self, other):
        """
        NAME: IMPL.builtins.int.__isub__
        NATIVE
        """
        if isinstance(other, int):
            return int()
        else:
            TypeConstraintError

    def __add__(self, other):
        """
        NAME: IMPL.builtins.int.__add__
        NATIVE
        """
        if isinstance(other, int):
            return int()
        else:
            TypeConstraintError

    def __radd__(self, other):
        """
        NAME: IMPL.builtins.int.__radd__
        NATIVE
        """
        if isinstance(other, int):
            return int()
        else:
            TypeConstraintError

    def __sub__(self, other):
        """
        NAME: IMPL.builtins.int.__add__
        NATIVE
        """
        if isinstance(other, int):
            return int()
        else:
            TypeConstraintError

    def __rsub__(self, other):
        """
        NAME: IMPL.builtins.int.__radd__
        NATIVE
        """
        if isinstance(other, int):
            return int()
        else:
            TypeConstraintError

    def __mul__(self, other):
        """
        NAME: IMPL.builtins.int.__mul__
        NATIVE
        """
        if isinstance(other, int):
            return int()
        else:
            TypeConstraintError

    def __rmul__(self, other):
        """
        NAME: IMPL.builtins.int.__rmul__
        NATIVE
        """
        if isinstance(other, int):
            return int()
        else:
            TypeConstraintError

    def __and__(self, other):
        """
        NAME: IMPL.builtins.int.__mul__
        NATIVE
        """
        if isinstance(other, int):
            return int()
        else:
            TypeConstraintError

    def __rand__(self, other):
        """
        NAME: IMPL.builtins.int.__rmul__
        NATIVE
        """
        if isinstance(other, int):
            return int()
        else:
            TypeConstraintError

    def __or__(self, other):
        """
        NAME: IMPL.builtins.int.__mul__
        NATIVE
        """
        if isinstance(other, int):
            return int()
        else:
            TypeConstraintError

    def __ror__(self, other):
        """
        NAME: IMPL.builtins.int.__rmul__
        NATIVE
        """
        if isinstance(other, int):
            return int()
        else:
            TypeConstraintError

    def __xor__(self, other):
        """
        NAME: IMPL.builtins.int.__mul__
        NATIVE
        """
        if isinstance(other, int):
            return int()
        else:
            TypeConstraintError

    def __rxor__(self, other):
        """
        NAME: IMPL.builtins.int.__rmul__
        NATIVE
        """
        if isinstance(other, int):
            return int()
        else:
            TypeConstraintError            

    def __div__(self, other):
        """
        NAME: IMPL.builtins.int.__div__
        NATIVE
        """
        if isinstance(other, int):
            return int()
        else:
            TypeConstraintError

    def __rdiv__(self, other):
        """
        NAME: IMPL.builtins.int.__rdiv__
        NATIVE
        """
        if isinstance(other, int):
            return int()
        else:
            TypeConstraintError

    def __pow__(self, other):
        """
        NAME: IMPL.builtins.int.__pow__
        NATIVE
        """
        if isinstance(other, int):
            return int()
        else:
            TypeConstraintError

    def __lt__(self, other):
        """
        NAME: IMPL.builtins.int.__lt__
        NATIVE
        """
        if isinstance(other, int):
            return boolean()
        else:
            TypeConstraintError

    def __gt__(self, other):
        """
        NAME: IMPL.builtins.int.__gt__
        NATIVE
        """
        if isinstance(other, int):
            return boolean()
        else:
            TypeConstraintError

    def __le__(self, other):
        """
        NAME: IMPL.builtins.int.__le__
        NATIVE
        """
        if isinstance(other, int):
            return boolean()
        else:
            TypeConstraintError

    def __lshift__(self,other):
        """
        NAME: IMPL.builtins.int.__lshift__
        NATIVE
        """
        if isinstance(other, int):
            return int()
        else:
            TypeConstraintError

    def __rshift__(self,other):
        """
        NAME: IMPL.builtins.int.__lshift__
        NATIVE
        """
        if isinstance(other, int):
            return int()
        else:
            TypeConstraintError

    def __ge__(self, other):
        """
        NAME: IMPL.builtins.int.__ge__
        NATIVE
        """
        if isinstance(other, int):
            return boolean()
        else:
            TypeConstraintError

    def __eq__(self, other):
        """
        NAME: IMPL.builtins.int.__eq__
        NATIVE
        """
        if isinstance(other, int):
            return boolean()
        else:
            TypeConstraintError

    def __ne__(self, other):
        """
        NAME: IMPL.builtins.int.__ne__
        NATIVE
        """
        if isinstance(other, int):
            return boolean()
        else:
            TypeConstraintError

    def __neg__(self):
        """
        NAME: IMPL.builtins.int.__neg__
        NATIVE
        """
        return int()

    def __pos__(self):
        return self

    def __str__(self):
        """
        NAME: IMPL.builtins.int.__str__
        NATIVE
        """
        return string()

    def __true__(self):
        return self != 0

class long:
    """
    NATIVE
    INTERCHANGEABLE
    """
    def __iadd__(self, other):
        """
        NAME: IMPL.builtins.long.__iadd__
        NATIVE
        """
        if isinstance(other, int):
            return long()
        elif isinstance(other, long):
            return long()
        else:
            TypeConstraintError

    def __isub__(self, other):
        """
        NAME: IMPL.builtins.long.__isub__
        NATIVE
        """
        if isinstance(other, int):
            return long()
        elif isinstance(other, long):
            return long()
        else:
            TypeConstraintError

    def __add__(self, other):
        """
        NAME: IMPL.builtins.long.__add__
        NATIVE
        """
        if isinstance(other, int):
            return long()
        elif isinstance(other, long):
            return long()
        else:
            TypeConstraintError

    def __radd__(self, other):
        """
        NAME: IMPL.builtins.long.__radd__
        NATIVE
        """
        if isinstance(other, int):
            return long()
        elif isinstance(other, long):
            return long()
        else:
            TypeConstraintError

    def __sub__(self, other):
        """
        NAME: IMPL.builtins.long.__sub__
        NATIVE
        """
        if isinstance(other, int):
            return long()
        elif isinstance(other, long):
            return long()
        else:
            TypeConstraintError

    def __rsub__(self, other):
        """
        NAME: IMPL.builtins.long.__rsub__
        NATIVE
        """
        if isinstance(other, int):
            return long()
        elif isinstance(other, long):
            return long()
        else:
            TypeConstraintError

    def __lt__(self, other):
        """
        NAME: IMPL.builtins.long.__lt__
        NATIVE
        """
        if isinstance(other, int):
            return boolean()
        elif isinstance(other, long):
            return boolean()
        else:
            TypeConstraintError

    def __gt__(self, other):
        """
        NAME: IMPL.builtins.long.__gt__
        NATIVE
        """
        if isinstance(other, int):
            return boolean()
        elif isinstance(other, long):
            return boolean()
        else:
            TypeConstraintError

    def __le__(self, other):
        """
        NAME: IMPL.builtins.long.__le__
        NATIVE
        """
        if isinstance(other, int):
            return boolean()
        elif isinstance(other, long):
            return boolean()
        else:
            TypeConstraintError

    def __ge__(self, other):
        """
        NAME: IMPL.builtins.long.__ge__
        NATIVE
        """
        if isinstance(other, int):
            return boolean()
        elif isinstance(other, long):
            return boolean()
        else:
            TypeConstraintError

    def __eq__(self, other):
        """
        NAME: IMPL.builtins.long.__eq__
        NATIVE
        """
        if isinstance(other, int):
            return boolean()
        elif isinstance(other, long):
            return boolean()
        else:
            TypeConstraintError

    def __ne__(self, other):
        """
        NAME: IMPL.builtins.long.__ne__
        NATIVE
        """
        if isinstance(other, int):
            return boolean()
        elif isinstance(other, long):
            return boolean()
        else:
            TypeConstraintError

    def __neg__(self):
        """
        NAME: IMPL.builtins.long.__neg__
        NATIVE
        """
        return long()

    def __pos__(self):
        return self

    def __str__(self):
        """
        NAME: IMPL.builtins.long.__str__
        NATIVE
        """
        return string()

    def __true__(self):
        return self != 0

class float:
    """
    NATIVE
    INTERCHANGEABLE
    """
    def __iadd__(self, other):
        """
        NAME: IMPL.builtins.float.__iadd__
        NATIVE
        """
        if isinstance(other, int):
            return float()
        elif isinstance(other, long):
            return float()
        elif isinstance(other, float):
            return float()
        else:
            TypeConstraintError

    def __isub__(self, other):
        """
        NAME: IMPL.builtins.float.__isub__
        NATIVE
        """
        if isinstance(other, int):
            return float()
        elif isinstance(other, long):
            return float()
        elif isinstance(other, float):
            return float()
        else:
            TypeConstraintError

    def __add__(self, other):
        """
        NAME: IMPL.builtins.float.__add__
        NATIVE
        """
        if isinstance(other, int):
            return float()
        elif isinstance(other, long):
            return float()
        elif isinstance(other, float):
            return float()
        else:
            TypeConstraintError

    def __radd__(self, other):
        """
        NAME: IMPL.builtins.float.__radd__
        NATIVE
        """
        if isinstance(other, int):
            return float()
        elif isinstance(other, long):
            return float()
        elif isinstance(other, float):
            return float()
        else:
            TypeConstraintError

    def __sub__(self, other):
        """
        NAME: IMPL.builtins.float.__sub__
        NATIVE
        """
        if isinstance(other, int):
            return float()
        elif isinstance(other, long):
            return float()
        elif isinstance(other, float):
            return float()
        else:
            TypeConstraintError

    def __rsub__(self, other):
        """
        NAME: IMPL.builtins.float.__rsub__
        NATIVE
        """
        if isinstance(other, int):
            return float()
        elif isinstance(other, long):
            return float()
        elif isinstance(other, float):
            return float()
        else:
            TypeConstraintError

    def __mul__(self, other):
        """
        NAME: IMPL.builtins.float.__mul__
        NATIVE
        """
        if isinstance(other, int):
            return float()
        elif isinstance(other, long):
            return float()
        elif isinstance(other, float):
            return float()
        else:
            TypeConstraintError

    def __rmul__(self, other):
        """
        NAME: IMPL.builtins.float.__rmul__
        NATIVE
        """
        if isinstance(other, int):
            return float()
        elif isinstance(other, long):
            return float()
        elif isinstance(other, float):
            return float()
        else:
            TypeConstraintError

    def __div__(self, other):
        """
        NAME: IMPL.builtins.float.__div__
        NATIVE
        """
        if isinstance(other, int):
            return float()
        elif isinstance(other, long):
            return float()
        elif isinstance(other, float):
            return float()
        else:
            TypeConstraintError

    def __rdiv__(self, other):
        """
        NAME: IMPL.builtins.float.__rdiv__
        NATIVE
        """
        if isinstance(other, int):
            return float()
        elif isinstance(other, long):
            return float()
        elif isinstance(other, float):
            return float()
        else:
            TypeConstraintError

    def __pow__(self, other):
        """
        NAME: IMPL.builtins.float.__pow__
        NATIVE
        """
        if isinstance(other, int):
            return float()
        elif isinstance(other, long):
            return float()
        elif isinstance(other, float):
            return float()
        else:
            TypeConstraintError

    def __rpow__(self, other):
        """
        NAME: IMPL.builtins.float.__rpow__
        NATIVE
        """
        if isinstance(other, int):
            return float()
        elif isinstance(other, long):
            return float()
        elif isinstance(other, float):
            return float()
        else:
            TypeConstraintError

    def __lt__(self, other):
        """
        NAME: IMPL.builtins.float.__lt__
        NATIVE
        """
        if isinstance(other, int):
            return boolean()
        elif isinstance(other, long):
            return boolean()
        elif isinstance(other, float):
            return boolean()
        else:
            TypeConstraintError

    def __gt__(self, other):
        """
        NAME: IMPL.builtins.float.__gt__
        NATIVE
        """
        if isinstance(other, int):
            return boolean()
        elif isinstance(other, long):
            return boolean()
        elif isinstance(other, float):
            return boolean()
        else:
            TypeConstraintError

    def __le__(self, other):
        """
        NAME: IMPL.builtins.float.__le__
        NATIVE
        """
        if isinstance(other, int):
            return boolean()
        elif isinstance(other, long):
            return boolean()
        elif isinstance(other, float):
            return boolean()
        else:
            TypeConstraintError

    def __ge__(self, other):
        """
        NAME: IMPL.builtins.float.__ge__
        NATIVE
        """
        if isinstance(other, int):
            return boolean()
        elif isinstance(other, long):
            return boolean()
        elif isinstance(other, float):
            return boolean()
        else:
            TypeConstraintError

    def __eq__(self, other):
        """
        NAME: IMPL.builtins.float.__eq__
        NATIVE
        """
        if isinstance(other, int):
            return boolean()
        elif isinstance(other, long):
            return boolean()
        elif isinstance(other, float):
            return boolean()
        else:
            TypeConstraintError

    def __ne__(self, other):
        """
        NAME: IMPL.builtins.float.__ne__
        NATIVE
        """
        if isinstance(other, int):
            return boolean()
        elif isinstance(other, long):
            return boolean()
        elif isinstance(other, float):
            return boolean()
        else:
            TypeConstraintError

    def __neg__(self):
        """
        NAME: IMPL.builtins.float.__neg__
        NATIVE
        """
        return float()

    def __pos__(self):
        return self

    def __str__(self):
        """
        NAME: IMPL.builtins.float.__str__
        NATIVE
        """
        return string()

    def __true__(self):
        return self != 0
class stringiterator:
    """
    NATIVE
    INTERCHANGEABLE
    """
    def next(self):
        return string()

def divmod(a,b):
    return (int(),int())

class string:
    """
    NATIVE
    INTERCHANGEABLE
    """
    def __add__(self, other):
        """
        NAME: IMPL.builtins.string.__add__
        NATIVE
        """
        if isinstance(other, string):
            return string()
        else:
            TypeConstraintError

    def __iadd__(self, other):
        """
        NAME: IMPL.builtins.string.__add__
        NATIVE
        """
        if isinstance(other, string):
            return string()
        else:
            TypeConstraintError
    def count(self,other):
        return int()
    def __radd__(self, other):
        """
        NAME: IMPL.builtins.string.__radd__
        NATIVE
        """
        if isinstance(other, string):
            return string()
        else:
            TypeConstraintError

    def __len__(self):
        """
        NAME: IMPL.builtins.string.__len__
        NATIVE
        """
        return int()

    def __str__(self):
        return self

    def __true__(self):
        return self.__len__() != 0
    def __iter__(self):
        return stringiterator()
    def __mod__(self,other):
        if isinstance(other, string):
            return string()
        else:
            TypeConstraintError

    def join(self, l):
        total = 0
        first = 1
        self_len = self.__len__()
        for i in l:
            if not first:
                total += self_len
            total += len(str(i))
            first = 0
        b = buffer(total)
        first = 1
        for i in l:
            if not first:
                b.append(self)
            b.append(str(i))
            first = 0
        s = str(b)
        return s
    def __getslice__(self,f,t):
        return self
    def startswith(self,char):
        return boolean()
    def endswith(self,char):
        return boolean()
    def rFind(self,targ):
        return int()
    def find(self,targ):
        return int()
    def rstrip(self,char=" "):
        return string()
    def lstrip(self,char=" "):
        return string()
    def strip(self,char=" "):
        return self.lstrip().rstrip()
    def split(self,char=" ", len=-1):
        return []

class buffer:
    """
    NATIVE
    INTERCHANGEABLE
    """
    def __init__(self, size=-1):
        """
        NAME: IMPL.builtins.buffer.__init__
        NATIVE
        """
        if not isinstance(size, int):
            TypeConstraintError

    def append(self, s):
        """
        NAME: IMPL.builtins.buffer.append
        NATIVE
        """
        if not isinstance(s, string):
            TypeConstraintError
        pass

    def __str__(self):
        """
        NAME: IMPL.builtins.buffer.__str__
        NATIVE
        """
        return string()

class list:
    def __init__(self):
        self.next = None
        self.last = self

    def __getitem__(self, index):
        i = 0
        n = self
        # NOTE: Support negative indices using last.
        while i < index and n.next is not None:
            n = n.next
            i += 1
        if n.next is not None:
            return n.value
        else:
            raise IndexError() # NOTE: Make this compliant with Python!

    def __setitem__(self, index, value):
        i = 0
        n = self
        # NOTE: Support negative indices using last.
        while i < index and n.next is not None:
            n = n.next
            i += 1
        if n.next is not None:
            n.value = value
        else:
            raise IndexError() # NOTE: Make this compliant with Python!

    def __getslice__(self, start, end=None):
        slice = []
        i = 0
        n = self
        # NOTE: Support negative indices using last.
        while (end is None or i < end) and n.next is not None:
            if i >= start:
                slice.append(n.value)
            n = n.next
            i += 1
        return slice

    def __setslice__(self, start, end, slice):
        i = 0
        n = self
        j = 0
        p = slice
        # NOTE: Support negative indices using last.
        # NOTE: Support appending when start >= len(self).
        while i < end and n is not None and p is not None:
            if i >= start:
                n.value = p.value
                p = p.next
                j += 1
            n = n.next
            i += 1

    def append(self, value):
        n = self.last
        n.value = value
        n.next = self.__class__()
        self.last = n.next

    def extend(self, other):
        for value in other:
            self.append(value)
    def index(self,other):
        return int()

    def __len__(self):
        i = 0
        n = self
        while n.next is not None:
            n = n.next
            i += 1
        return i

    def __add__(self, other):
        result = self.__class__()
        for value in self:
            result.append(value)
        for value in other:
            result.append(value)
        return result

    def __str__(self):
        output = ["["]
        n = self
        first = 1
        while n.next is not None:
            if not first:
                output.append(", ")
            else:
                first = 0
            output.append(str(n.value))
            n = n.next
        output.append("]")
        return "".join(output)
    def add(self, value):
        i = 0
        n = self
        # NOTE: Support negative indices using last.
        while i < index and n.next is not None:
            if n.value==value:
                return
            n = n.next
            i += 1
        n = self.last
        n.value = value
        n.next = self.__class__()
        self.last = n.next
 
    def remove(self, value):
        pass
 
    def __iter__(self):
        return listiterator(self)

    def __true__(self):
        return self.__len__() != 0

class listiterator:
    def __init__(self, l):
        self.l = l

    def next(self):
        l = self.l
        next = l.next
        if next is not None:
            self.l = next
            return l.value
        else:
            raise StopIteration() # NOTE: Make this compliant with Python!

    def __true__(self):
        """
        NAME: IMPL.builtins.int.__true__
        NATIVE
        """
        return boolean()

def callable(arg):
    return boolean()

class tuple:
    def __init__(self):
        self.next = None
        self.last = self

    def __getitem__(self, index):
        i = 0
        n = self
        # NOTE: Support negative indices using last.
        while i < index and n.next is not None:
            n = n.next
            i += 1
        if n.next is not None:
            return n.value
        else:
            raise IndexError() # NOTE: Make this compliant with Python!

    def __getslice__(self, start, end=None):
        # NOTE: Should probably return a tuple.
        slice = []
        i = 0
        n = self
        # NOTE: Support negative indices using last.
        while (end is None or i < end) and n.next is not None:
            if i >= start:
                slice.append(n.value)
            n = n.next
            i += 1
        return slice

    # NOTE: The append method should be internal at most.

    def append(self, value):
        n = self.last
        n.value = value
        n.next = self.__class__()
        self.last = n.next

    def __len__(self):
        i = 0
        n = self
        while n.next is not None:
            n = n.next
            i += 1
        return i
    def __len__():
        return int()

    def __add__(self, other):
        result = self.__class__()
        for value in self:
            result.append(value)
        for value in other:
            result.append(value)
        return result

    def __str__(self):
        output = ["("]
        n = self
        first = 1
        while n.next is not None:
            if not first:
                output.append(", ")
            else:
                first = 0
            output.append(str(n.value))
            n = n.next
        output.append(")")
        return "".join(output)

    def __iter__(self):
        return tupleiterator(self)

    def __true__(self):
        return self.__len__() != 0

class tupleiterator:
    def __init__(self, l):
        self.l = l

    def next(self):
        l = self.l
        next = l.next
        if next is not None:
            self.l = next
            return l.value
        else:
            raise StopIteration() # NOTE: Make this compliant with Python!

    def __true__(self):
        """
        NAME: IMPL.builtins.int.__true__
        NATIVE
        """
        return boolean()

class Exception:
    pass

class StopIteration(Exception):
    pass

class IndexError(Exception):
    pass

class AttributeError(Exception):
    pass

class TypeError(Exception):
    pass

class none:
    """
    NATIVE
    INTERCHANGEABLE
    ATOMIC
    """
    def __true__(self):
        return False

    def __str__(self):
        return "None"

class undefined:
    """
    NATIVE
    INTERCHANGEABLE
    ATOMIC
    """
    pass

def isinstance(obj, cls):
    """
    NAME: IMPL.builtins.isinstance
    NATIVE
    SPECIAL
    """
    return boolean()

def issubclass(cls1, cls2):
    """
    NAME: IMPL.builtins.isinstance
    NATIVE
    SPECIAL
    """
    return boolean()

def len(x):
    return x.__len__()

def max(*l):
    max_so_far = l[0]
    for i in l[1:]:
        if i > max_so_far:
            max_so_far = i
    return max_so_far

def str(x):
    return x.__str__()
def iter(x):
    return x.__iter__()

class object():
    def __init__():
        pass

class xrange:
    def __init__(self, start, end=-1, step=1):
        self.start = start
        self.end = end
        self.step = step
        self.current = start

    def __iter__(self):
        return self

    def next(self):
        if self.current >= self.end:
            raise StopIteration()
        current = self.current
        self.current += self.step
        return current

class dict:
    def __init__(self):
        self.next = None
        self.last = self
    def get(self,k,default=None):
        n=self        
        while n.next is not None:
            if n.value==value:
                return n.key
            n = n.next
        return default

    def __setitem__(self, k,value):
        n=self        
        while n.next is not None:
            if n.value==value:
                n.key=k
            n = n.next
        if n.next==None:
            n = self.last
            n.value = value
            n.key=k
            n.next = self.__class__()
            self.last = n.next

    def __getitem__(self,key):
        n=self        
        while n.next is not None:
            if n.value==value:
                return n.key
            n = n.next

    def __delitem__(self, key):
        pass

    def __len__(self):
        i = 0
        n = self
        while n.next is not None:
            n = n.next
            i += 1
        return i

    def __true__(self):
        return self.__len__() != 0
    def __contains__(self,a):
        return True
    def __notcontains__(self,a):
        return False
    def items(self):
        return [tuple()]

def __import__(target):
    eval_code_in_interpreter="""
print "WARNING: dynamic import!"
print "   %s at line %d"%(ast2string(self.lastfunc),self.lastfunc.lineno)
"""
    pass

class set:
    def __init__(self):
        self.next = None
        self.last = self

    def add(self, value):
        pass
        eval_code_in_interpreter="""
for t in handler.locals['self']: 
    if not hasattr(t,'types'):
        t.types=set()
    for T in handler.locals['value']:
        t.types.add(T)
"""
        eval_code_in_interpreter="""
for t in handler.locals['self']: 
    if not hasattr(t,'values'):
        t.values=set()
    for T in handler.locals['value']:
        t.values.add(T)
"""
        n=self        
        while n.next is not None:
            if n.value==value:
                break 
            n = n.next
        eval_code_in_interpreter="""
skipblock=True
for t in handler.locals['self']:
    if "last" in t._namespace:
        skipblock=False
if skipblock:
    handler.skiprestofblock=True
#   pdb.set_trace()
"""
        if n.next==None:
            n = self.last
            n.value = value
            n.next = self.__class__()
            self.last = n.next
    def remove(self, value):
        pass
    def pop(self):
        n=self
        assert n.next is not None, "Popping from empty set!"

        while n.next is not None:
            n = n.next
        ret=n.next
        self.last=n
        n.next=None
        return ret

    def __len__(self):
        i = 0
        n = self
        while n.next is not None:
            n = n.next
            i += 1
        return i
    def issubset(self,s):
        """
        NATIVE
        INTERCHANGEABLE
        """
        return boolean()

    def copy(self):
        return self
        #x=Set()
        #n = self
        #while n.next is not None:
        #    n = n.next
        #    x.add(n)
            
    def __str__(self):
        output = ["("]
        n = self
        first = 1
        while n.next is not None:
            if not first:
                output.append(", ")
            else:
                first = 0
            output.append(str(n.value))
            n = n.next
        output.append(")")
        return "".join(output)

    def __iter__(self):
        return setiterator(self)

    def __true__(self):
        return self.__len__() != 0
    def str(self):
        return self.__str__a
    def __contains__(self,a):
        return True
    def __notcontains__(self,a):
        return False

class type:
    def __init__(self,arg):
        pass

def dir():
    return [string(),string()]

class setiterator:
    def __init__(self, l):
        self.l = l

    def next(self):
        l = self.l
        next = l.next
        if next is not None:
            self.l = next
            return l.value
        else:
            raise StopIteration() # NOTE: Make this compliant with Python!

    def __iter__(self):
        return setiterator(self.l)

    def __true__(self):
        """
        NAME: IMPL.builtins.int.__true__
        NATIVE
        """
        return boolean()


# Special values. None of these definitions should be generated by the compiler.
# All such definitions should be made in the underlying implementation.

True = boolean()
False = boolean()
None = none()
Undefined = undefined()

# Special functions. These all operate on references at run-time.

def __is__(a, b):
    """
    NAME: IMPL.builtins.__is__
    NATIVE
    """
    return boolean()

def __is_not__(a, b):
    """
    NAME: IMPL.builtins.__is_not__
    NATIVE
    """
    return boolean()

def __not__(a):
    """
    NAME: IMPL.builtins.__not__
    NATIVE
    """
    return boolean()

def getattr(o,a,d=None):
    return d

def hasattr(o,n):
    if isinstance(n, string):
        return boolean()
    else:
        TypeConstraintError

def bool(x):
    return boolean()

def chr(x):
    return string()

def id(x):
    return int()

def range(n):
    return list()

class ValueError(Exception):
    pass

def ord(x):
    return int()
# vim: tabstop=4 expandtab shiftwidth=4

